.. ..::

   Copyright (c) 2024 OpenHW Group
   Copyright (c) 2024 Thales
   SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
   Author: Abdessamii Oukalrazqou

===
isa
===

Instructions
------------

+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Subset Name   | Name                                                | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
+===============+=====================================================+======================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================+
| I             | RV32I Base Integer Instructions_                    | the base integer instruction set, also known as the 'RV32I' or 'RV64I' instruction set , depending on the address space size, provides the core functionality required for general-purpose computing .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|               |                                                     | it includes instructions for arithmetic, logical, and control operations, as well as memory access                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|               |                                                     | and manipulation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| M             | RV32M Multiplication and Division Instructions_     | the standard integer multiplication and division instruction extension, which is named “M” and contains instructions that multiply or divide values held in two integer registers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| C             | RV32C Compressed Instructions_                      | RVC uses a simple compression scheme that offers shorter 16-bit versions of common 32-bit RISC-V instructions when:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|               |                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|               |                                                     |     the immediate or address offset is small;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|               |                                                     |     one of the registers is the zero register (x0), the ABI link register (x1), or the ABI stack pointer (x2);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|               |                                                     |     the destination register and the first source register are identical;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|               |                                                     |     the registers used are the 8 most popular ones.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|               |                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|               |                                                     | The C extension is compatible with all other standard instruction extensions. The C extension allows 16-bit instructions to be freely intermixed with 32-bit instructions, with the latter now able to start on any 16-bit boundary. With the addition of the C extension, JAL and JALR instructions will no longer raise an instruction misaligned exception                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Zicsr         | RV32Zicsr Control and Status Register Instructions_ | All CSR instructions atomically read-modify-write a single CSR, whose CSR specifier is encoded in the 12-bit csr field of the instruction held in bits 31–20. The immediate forms use a 5-bit zero-extended immediate encoded in the rs1 field.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Zcb           | RV32Zcb Code Size Reduction Instructions_           | Zcb belongs to the group of extensions called RISC-V Code Size Reduction Extension (Zc*). Zc* has become the superset of the Standard C extension adding more 16-bit instructions to the ISA. Zcb includes the 16-bit version of additional Integer (I), Multiply (M), and Bit-Manipulation (Zbb) Instructions. All the Zcb instructions require at least standard C extension support as a prerequisite, along with M and Zbb extensions for the 16-bit version of the respective instructions.                                                                                                                                                                                                                                                                                                                                                                     |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Zba           | RVZba Address generation instructions_              | The Zba instructions can be used to accelerate the generation of addresses that index into arrays of basic types (halfword, word, doubleword) using both unsigned word-sized and XLEN-sized indices: a shifted index is added to a base address. The shift and add instructions do a left shift of 1, 2, or 3 because these are commonly found in real-world code and because they can be implemented with a minimal amount of additional hardware beyond that of the simple adder. This avoids lengthening the critical path in implementations. While the shift and add instructions are limited to a maximum left shift of 3, the slli instruction (from the base ISA) can be used to perform similar shifts for indexing into arrays of wider elements. The slli.uw added in this extension can be used when the index is to be interpreted as an unsigned word. |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Zbb           | RVZbb Basic bit-manipulation_                       | The bit-manipulation (bitmanip) extension collection is comprised of several component extensions to the base RISC-V architecture that are intended to provide some combination of code size reduction, performance improvement, and energy reduction.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|               |                                                     | While the instructions are intended to have general use, some instructions are more useful in some domains than others. Hence, several smaller bitmanip extensions are provided. Each of these smaller extensions is grouped by common function and use case, and each has its own Zb*-extension name.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Zbc           | RVZbc Carry-less multiplication_                    | Carry-less multiplication is the multiplication in the polynomial ring over GF(2).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|               |                                                     | clmul produces the lower half of the carry-less product and clmulh produces the upper half of the 2✕XLEN carry-less product.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|               |                                                     | clmulr produces bits 2✕XLEN−2:XLEN-1 of the 2✕XLEN carry-less product.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Zbs           | RVZbs Single bit Instructions_                      | The single-bit instructions provide a mechanism to set, clear, invert, or extract a single bit in a register. The bit is specified by its index.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Zicntr        | Zicntr_                                             | No info found yet for extension Zicntr                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Zbkb          | RVZbkb Bitmanip instructions for Cryptography_      | The Zbkb extension is a part of the RISC-V Bit-Manipulation (bitmanip) extensions, specifically targeting cryptographic applications. It introduces a set of instructions designed to facilitate operations commonly used in cryptographic algorithms, such as interleaving, packing, and reordering of bits.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
+---------------+-----------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

RV32I Base Integer Instructions
-------------------------------


+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| Name   | Format                   | Pseudocode                                                        | Invalid_values   | Exception_raised                                                                                                                                                                                                                                                               | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Op Name                                          |
+========+==========================+===================================================================+==================+================================================================================================================================================================================================================================================================================+=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================+==================================================+
| ADDI   | addi rd, rs1, imm[11:0]  | x[rd] = x[rs1] + sext(imm[11:0])                                  | NONE             | NONE                                                                                                                                                                                                                                                                           | add sign-extended 12-bit immediate to register rs1, and store the result in register rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| ANDI   | andi rd, rs1, imm[11:0]  | x[rd] = x[rs1] & sext(imm[11:0])                                  | NONE             | NONE                                                                                                                                                                                                                                                                           | perform bitwise AND on register rs1 and the sign-extended 12-bit immediate and place the result in rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| ORI    | ori rd, rs1, imm[11:0]   | x[rd] = x[rs1] | sext(imm[11:0])                                  | NONE             | NONE                                                                                                                                                                                                                                                                           | perform bitwise OR on register rs1 and the sign-extended 12-bit immediate and place the result in rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| XORI   | xori rd, rs1, imm[11:0]  | x[rd] = x[rs1] ^ sext(imm[11:0])                                  | NONE             | NONE                                                                                                                                                                                                                                                                           | perform bitwise XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SLTI   | slti rd, rs1, imm[11:0]  | if (x[rs1] < sext(imm[11:0])) x[rd] = 1 else x[rd] = 0            | NONE             | NONE                                                                                                                                                                                                                                                                           | set register rd to 1 if register rs1 is less than the sign extended immediate when both are treated as signed numbers, else 0 is written to rd.                                                                                                                                                                                                                                                                                                                                                                                                                             | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SLTIU  | sltiu rd, rs1, imm[11:0] | if (x[rs1] <u sext(imm[11:0])) x[rd] = 1 else x[rd] = 0           | NONE             | NONE                                                                                                                                                                                                                                                                           | set register rd to 1 if register rs1 is less than the sign extended immediate when both are treated as unsigned numbers, else 0 is written to rd."                                                                                                                                                                                                                                                                                                                                                                                                                          | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SLLI   | slli rd, rs1, imm[4:0]   | x[rd] = x[rs1] << imm[4:0]                                        | NONE             | NONE                                                                                                                                                                                                                                                                           | logical left shift (zeros are shifted into the lower bits).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SRLI   | srli rd, rs1, imm[4:0]   | x[rd] = x[rs1] >> imm[4:0]                                        | NONE             | NONE                                                                                                                                                                                                                                                                           | logical right shift (zeros are shifted into the upper bits).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SRAI   | srai rd, rs1, imm[4:0]   | x[rd] = x[rs1] >>s imm[4:0]                                       | NONE             | NONE                                                                                                                                                                                                                                                                           | arithmetic right shift (the original sign bit is copied into the vacated upper bits).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| LUI    | lui rd, imm[19:0]        | x[rd] = sext(imm[31:12] << 12)                                    | NONE             | NONE                                                                                                                                                                                                                                                                           | place the immediate value in the top 20 bits of the destination register rd, filling in the lowest 12 bits with zeros.                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| AUIPC  | auipc rd, imm[19:0]      | x[rd] = pc + sext(immediate[31:12] << 12)                         | NONE             | NONE                                                                                                                                                                                                                                                                           | form a 32-bit offset from the 20-bit immediate, filling in the lowest 12 bits with zeros, adds this offset to the pc, then place the result in register rd.                                                                                                                                                                                                                                                                                                                                                                                                                 | Integer_Register_Immediate_Operations            |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| ADD    | add rd, rs1, rs2         | x[rd] = x[rs1] + x[rs2]                                           | NONE             | NONE                                                                                                                                                                                                                                                                           | add rs2 to register rs1, and store the result in register rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Integer_Register_Register_Operations             |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SUB    | sub rd, rs1, rs2         | x[rd] = x[rs1] - x[rs2]                                           | NONE             | NONE                                                                                                                                                                                                                                                                           | subtract rs2 from register rs1, and store the result in register rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Integer_Register_Register_Operations             |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| AND    | and rd, rs1, rs2         | x[rd] = x[rs1] & x[rs2]                                           | NONE             | NONE                                                                                                                                                                                                                                                                           | perform bitwise AND on register rs1 and rs2 and place the result in rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Integer_Register_Register_Operations             |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| OR     | or rd, rs1, rs2          | x[rd] = x[rs1] | x[rs2]                                           | NONE             | NONE                                                                                                                                                                                                                                                                           | perform bitwise OR on register rs1 and rs2 and place the result in rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Integer_Register_Register_Operations             |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| XOR    | xor rd, rs1, rs2         | x[rd] = x[rs1] ^ x[rs2]                                           | NONE             | NONE                                                                                                                                                                                                                                                                           | perform bitwise XOR on register rs1 and rs2 and place the result in rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Integer_Register_Register_Operations             |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SLT    | slt rd, rs1, rs2         | if (x[rs1] < x[rs2]) x[rd] = 1 else x[rd] = 0                     | NONE             | NONE                                                                                                                                                                                                                                                                           | set register rd to 1 if register rs1 is less than rs2 when both are treated as signed numbers, else 0 is written to rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Integer_Register_Register_Operations             |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SLTU   | sltu rd, rs1, rs2        | if (x[rs1] <u x[rs2]) x[rd] = 1 else x[rd] = 0                    | NONE             | NONE                                                                                                                                                                                                                                                                           | set register rd to 1 if register rs1 is less than rs2 when both are treated as unsigned numbers, else 0 is written to rd.                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Integer_Register_Register_Operations             |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SLL    | sll rd, rs1, rs2         | x[rd] = x[rs1] << x[rs2]                                          | NONE             | NONE                                                                                                                                                                                                                                                                           | logical left shift (zeros are shifted into the lower bits).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Integer_Register_Register_Operations             |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SRL    | srl rd, rs1, rs2         | x[rd] = x[rs1] >> x[rs2]                                          | NONE             | NONE                                                                                                                                                                                                                                                                           | logical right shift (zeros are shifted into the upper bits).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Integer_Register_Register_Operations             |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SRA    | sra rd, rs1, rs2         | x[rd] = x[rs1] >>s x[rs2]                                         | NONE             | NONE                                                                                                                                                                                                                                                                           | arithmetic right shift (the original sign bit is copied into the vacated upper bits).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Integer_Register_Register_Operations             |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| JAL    | jal rd, imm[20:1]        | x[rd] = pc+4; pc += sext(imm[20:1])                               | NONE             | jumps to an unaligned address (4-byte or 2-byte boundary) will usually raise an exception.                                                                                                                                                                                     | offset is sign-extended and added to the pc to form the jump target address (pc is calculated using signed arithmetic), then setting the least-significant bit of the result to zero, and store the address of instruction following the jump (pc+4) into register rd.                                                                                                                                                                                                                                                                                                      | Control_Transfer_Operations-Unconditional_Jumps  |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| JALR   | jalr rd, rs1, imm[11:0]  | t = pc+4; pc = (x[rs1]+sext(imm[11:0]))&∼1 ; x[rd] = t            | NONE             | jumps to an unaligned address (4-byte or 2-byte boundary) will usually raise an exception.                                                                                                                                                                                     | target address is obtained by adding the 12-bit signed immediate to the register rs1 (pc is calculated using signed arithmetic), then setting the least-significant bit of the result to zero, and store the address of instruction following the jump (pc+4) into register rd.                                                                                                                                                                                                                                                                                             | Control_Transfer_Operations-Unconditional_Jumps  |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| BEQ    | beq rs1, rs2, imm[12:1]  | if (x[rs1] == x[rs2]) pc += sext({imm[12:1], 1’b0}) else pc += 4  | NONE             | no instruction fetch misaligned exception is generated for a conditional branch that is not taken. An Instruction address misaligned exception is raised if the target address is not aligned on 4-byte or 2-byte boundary, because the core supports compressed instructions. | takes the branch (pc is calculated using signed arithmetic) if registers rs1 and rs2 are equal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Control_Transfer_Operations-Conditional_Branches |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| BNE    | bne rs1, rs2, imm[12:1]  | if (x[rs1] != x[rs2]) pc += sext({imm[12:1], 1’b0}) else pc += 4  | NONE             | no instruction fetch misaligned exception is generated for a conditional branch that is not taken. An Instruction address misaligned exception is raised if the target address is not aligned on 4-byte or 2-byte boundary, because the core supports compressed instructions. | takes the branch (pc is calculated using signed arithmetic) if registers rs1 and rs2 are not equal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Control_Transfer_Operations-Conditional_Branches |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| BLT    | blt rs1, rs2, imm[12:1]  | if (x[rs1] < x[rs2]) pc += sext({imm[12:1], 1’b0}) else pc += 4   | NONE             | no instruction fetch misaligned exception is generated for a conditional branch that is not taken. An Instruction address misaligned exception is raised if the target address is not aligned on 4-byte or 2-byte boundary, because the core supports compressed instructions. | takes the branch (pc is calculated using signed arithmetic) if registers rs1 less than rs2 (using signed comparison).                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Control_Transfer_Operations-Conditional_Branches |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| BLTU   | bltu rs1, rs2, imm[12:1] | if (x[rs1] <u x[rs2]) pc += sext({imm[12:1], 1’b0}) else pc += 4  | NONE             | no instruction fetch misaligned exception is generated for a conditional branch that is not taken. An Instruction address misaligned exception is raised if the target address is not aligned on 4-byte or 2-byte boundary, because the core supports compressed instructions. | takes the branch (pc is calculated using signed arithmetic) if registers rs1 less than rs2 (using unsigned comparison).                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Control_Transfer_Operations-Conditional_Branches |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| BGE    | bge rs1, rs2, imm[12:1]  | if (x[rs1] >= x[rs2]) pc += sext({imm[12:1], 1’b0}) else pc += 4  | NONE             | no instruction fetch misaligned exception is generated for a conditional branch that is not taken. An Instruction address misaligned exception is raised if the target address is not aligned on 4-byte or 2-byte boundary, because the core supports compressed instructions. | takes the branch (pc is calculated using signed arithmetic) if registers rs1 is greater than or equal rs2 (using signed comparison).                                                                                                                                                                                                                                                                                                                                                                                                                                        | Control_Transfer_Operations-Conditional_Branches |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| BGEU   | bgeu rs1, rs2, imm[12:1] | if (x[rs1] >=u x[rs2]) pc += sext({imm[12:1], 1’b0}) else pc += 4 | NONE             | no instruction fetch misaligned exception is generated for a conditional branch that is not taken. An Instruction address misaligned exception is raised if the target address is not aligned on 4-byte or 2-byte boundary, because the core supports compressed instructions. | takes the branch (pc is calculated using signed arithmetic) if registers rs1 is greater than or equal rs2 (using unsigned comparison).                                                                                                                                                                                                                                                                                                                                                                                                                                      | Control_Transfer_Operations-Conditional_Branches |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| LB     | lb rd, imm(rs1)          | x[rd] = sext(M[x[rs1] + sext(imm[11:0])][7:0])                    | NONE             | loads with a destination of x0 must still raise any exceptions and action any other side effects even though the load value is discarded.                                                                                                                                      | loads a 8-bit value from memory, then sign-extends to 32-bit before storing in rd (rd is calculated using signed arithmetic), the effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.                                                                                                                                                                                                                                                                                                                                                  | Load_and_Store_Instructions                      |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| LH     | lh rd, imm(rs1)          | x[rd] = sext(M[x[rs1] + sext(imm[11:0])][15:0])                   | NONE             | loads with a destination of x0 must still raise any exceptions and action any other side effects even though the load value is discarded, also an exception is raised if the memory address isn't aligned (2-byte boundary).                                                   | loads a 16-bit value from memory, then sign-extends to 32-bit before storing in rd (rd is calculated using signed arithmetic), the effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.                                                                                                                                                                                                                                                                                                                                                 | Load_and_Store_Instructions                      |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| LW     | lw rd, imm(rs1)          | x[rd] = sext(M[x[rs1] + sext(imm[11:0])][31:0])                   | NONE             | loads with a destination of x0 must still raise any exceptions and action any other side effects even though the load value is discarded, also an exception is raised if the memory address isn't aligned (4-byte boundary).                                                   | loads a 32-bit value from memory, then storing in rd (rd is calculated using signed arithmetic). The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.                                                                                                                                                                                                                                                                                                                                                                               | Load_and_Store_Instructions                      |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| LBU    | lbu rd, imm(rs1)         | x[rd] = zext(M[x[rs1] + sext(imm[11:0])][7:0])                    | NONE             | loads with a destination of x0 must still raise any exceptions and action any other side effects even though the load value is discarded.                                                                                                                                      | loads a 8-bit value from memory, then zero-extends to 32-bit before storing in rd (rd is calculated using unsigned arithmetic), the effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.                                                                                                                                                                                                                                                                                                                                                | Load_and_Store_Instructions                      |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| LHU    | lhu rd, imm(rs1)         | x[rd] = zext(M[x[rs1] + sext(imm[11:0])][15:0])                   | NONE             | loads with a destination of x0 must still raise any exceptions and action any other side effects even though the load value is discarded, also an exception is raised if the memory address isn't aligned (2-byte boundary).                                                   | loads a 16-bit value from memory, then zero-extends to 32-bit before storing in rd (rd is calculated using unsigned arithmetic), the effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.                                                                                                                                                                                                                                                                                                                                               | Load_and_Store_Instructions                      |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SB     | sb rs2, imm(rs1)         | M[x[rs1] + sext(imm[11:0])][7:0] = x[rs2][7:0]                    | NONE             | NONE                                                                                                                                                                                                                                                                           | stores a 8-bit value from the low bits of register rs2 to memory, the effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.                                                                                                                                                                                                                                                                                                                                                                                                              | Load_and_Store_Instructions                      |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SH     | sh rs2, imm(rs1)         | M[x[rs1] + sext(imm[11:0])][15:0] = x[rs2][15:0]                  | NONE             | an exception is raised if the memory address isn't aligned (2-byte boundary).                                                                                                                                                                                                  | stores a 16-bit value from the low bits of register rs2 to memory, the effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.                                                                                                                                                                                                                                                                                                                                                                                                             | Load_and_Store_Instructions                      |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| SW     | sw rs2, imm(rs1)         | M[x[rs1] + sext(imm[11:0])][31:0] = x[rs2][31:0]                  | NONE             | an exception is raised if the memory address isn't aligned (4-byte boundary).                                                                                                                                                                                                  | stores a 32-bit value from register rs2 to memory, the effective address is obtained by adding register rs1 to the sign-extended 12-bit offset.                                                                                                                                                                                                                                                                                                                                                                                                                             | Load_and_Store_Instructions                      |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| FENCE  | fence pre, succ          | No operation (nop)                                                | NONE             | NONE                                                                                                                                                                                                                                                                           | order device I/O and memory accesses as viewed by other RISC-V harts and external devices or coprocessors. Any combination of device input (I), device output (O), memory reads (R), and memory writes (W) may be ordered with respect to any combination of the same. Informally, no other RISC-V hart or external device can observe any operation in the successor set following a FENCE before any operation in the predecessor set preceding the FENCE, as the core support 1 hart, the fence instruction has no effect so we can considerate it as a nop instruction. | Memory_Ordering                                  |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| ECALL  | ecall                    | RaiseException(EnvironmentCall)                                   | NONE             | Raise an Environment Call exception.                                                                                                                                                                                                                                           | make a request to the supporting execution environment, which is usually an operating system. The ABI for the system will define how parameters for the environment request are passed, but usually these will be in defined locations in the integer register file.                                                                                                                                                                                                                                                                                                        | Environment_Call_and_Breakpoints                 |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+
| EBREAK | ebreak                   | x[8 + rd'] = sext(x[8 + rd'][7:0])                                | NONE             | NONE                                                                                                                                                                                                                                                                           | This instruction takes a single source/destination operand. It sign-extends the least-significant byte in the operand by copying the most-significant bit in the byte (i.e., bit 7) to all of the more-significant bits. It also requires Bit-Manipulation (Zbb) extension support.                                                                                                                                                                                                                                                                                         | Environment_Call_and_Breakpoints                 |
+--------+--------------------------+-------------------------------------------------------------------+------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------+

RV32M Multiplication and Division Instructions
----------------------------------------------


+--------+---------------------+------------------------------------+------------------+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+
| Name   | Format              | Pseudocode                         | Invalid_values   | Exception_raised   | Description                                                                                                                                                                              | Op Name                   |
+========+=====================+====================================+==================+====================+==========================================================================================================================================================================================+===========================+
| MUL    | mul rd, rs1, rs2    | x[rd] = x[rs1] * x[rs2]            | NONE             | NONE               | performs a 32-bit × 32-bit multiplication and places the lower 32 bits in the destination register (Both rs1 and rs2 treated as signed numbers).                                         | Multiplication Operations |
+--------+---------------------+------------------------------------+------------------+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+
| MULH   | mulh rd, rs1, rs2   | x[rd] = (x[rs1] s*s x[rs2]) >>s 32 | NONE             | NONE               | performs a 32-bit × 32-bit multiplication and places the upper 32 bits in the destination register of the 64-bit product (Both rs1 and rs2 treated as signed numbers).                   | Multiplication Operations |
+--------+---------------------+------------------------------------+------------------+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+
| MULHU  | mulhu rd, rs1, rs2  | x[rd] = (x[rs1] u*u x[rs2]) >>u 32 | NONE             | NONE               | performs a 32-bit × 32-bit multiplication and places the upper 32 bits in the destination register of the 64-bit product (Both rs1 and rs2 treated as unsigned numbers).                 | Multiplication Operations |
+--------+---------------------+------------------------------------+------------------+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+
| MULHSU | mulhsu rd, rs1, rs2 | x[rd] = (x[rs1] s*u x[rs2]) >>s 32 | NONE             | NONE               | performs a 32-bit × 32-bit multiplication and places the upper 32 bits in the destination register of the 64-bit product (rs1 treated as signed number, rs2 treated as unsigned number). | Multiplication Operations |
+--------+---------------------+------------------------------------+------------------+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+
| DIV    | div rd, rs1, rs2    | x[rd] = x[rs1] /s x[rs2]           | NONE             | NONE               | perform signed integer division of 32 bits by 32 bits (rounding towards zero).                                                                                                           | Division Operations       |
+--------+---------------------+------------------------------------+------------------+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+
| DIVU   | divu rd, rs1, rs2   | x[rd] = x[rs1] /u x[rs2]           | NONE             | NONE               | perform unsigned integer division of 32 bits by 32 bits (rounding towards zero).                                                                                                         | Division Operations       |
+--------+---------------------+------------------------------------+------------------+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+
| REM    | rem rd, rs1, rs2    | x[rd] = x[rs1] %s x[rs2]           | NONE             | NONE               | provide the remainder of the corresponding division operation DIV (the sign of rd equals the sign of rs1).                                                                               | Division Operations       |
+--------+---------------------+------------------------------------+------------------+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+
| REMU   | rem rd, rs1, rs2    | x[rd] = x[rs1] %u x[rs2]           | NONE             | NONE               | provide the remainder of the corresponding division operation DIVU.                                                                                                                      | Division Operations       |
+--------+---------------------+------------------------------------+------------------+--------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------+

RV32C Compressed Instructions
-----------------------------


+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| Name       | Format                     | Pseudocode                                       | Invalid_values                | Exception_raised                                                                                                                                                                                                                                                               | Description                                                                                                                                                                                                                                                                                                                                     | Op Name                            |
+============+============================+==================================================+===============================+================================================================================================================================================================================================================================================================================+=================================================================================================================================================================================================================================================================================================================================================+====================================+
| C.LI       | c.li rd, imm[5:0]          | x[rd] = sext(imm[5:0])                           | rd = x0                       | NONE                                                                                                                                                                                                                                                                           | loads the sign-extended 6-bit immediate, imm, into register rd.                                                                                                                                                                                                                                                                                 | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.LUI      | c.lui rd, nzimm[17:12]     | x[rd] = sext(nzimm[17:12] << 12)                 | rd = x0 & rd = x2 & nzimm = 0 | NONE                                                                                                                                                                                                                                                                           | loads the non-zero 6-bit immediate field into bits 17–12 of the destination register, clears the bottom 12 bits, and sign-extends bit 17 into all higher bits of the destination.                                                                                                                                                               | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.ADDI     | c.addi rd, nzimm[5:0]      | x[rd] = x[rd] + sext(nzimm[5:0])                 | rd = x0 & nzimm = 0           | NONE                                                                                                                                                                                                                                                                           | adds the non-zero sign-extended 6-bit immediate to the value in register rd then writes the result to rd.                                                                                                                                                                                                                                       | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.ADDI16SP | c.addi16sp nzimm[9:4]      | x[2] = x[2] + sext(nzimm[9:4])                   | rd != x2 & nzimm = 0          | NONE                                                                                                                                                                                                                                                                           | adds the non-zero sign-extended 6-bit immediate to the value in the stack pointer (sp=x2), where the immediate is scaled to represent multiples of 16 in the range (-512,496). C.ADDI16SP is used to adjust the stack pointer in procedure prologues and epilogues. C.ADDI16SP shares the opcode with C.LUI, but has a destination field of x2. | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.ADDI4SPN | c.addi4spn rd', nzimm[9:2] | x[8 + rd'] = x[2] + zext(nzimm[9:2])             | nzimm = 0                     | NONE                                                                                                                                                                                                                                                                           | adds a zero-extended non-zero immediate, scaled by 4, to the stack pointer, x2, and writes the result to rd'. This instruction is used to generate pointers to stack-allocated variables.                                                                                                                                                       | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.SLLI     | c.slli rd, uimm[5:0]       | x[rd] = x[rd] << uimm[5:0]                       | rd = x0 & uimm[5] = 0         | NONE                                                                                                                                                                                                                                                                           | performs a logical left shift (zeros are shifted into the lower bits).                                                                                                                                                                                                                                                                          | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.SRLI     | c.srli rd', uimm[5:0]      | x[8 + rd'] = x[8 + rd'] >> uimm[5:0]             | uimm[5] = 0                   | NONE                                                                                                                                                                                                                                                                           | performs a logical right shift (zeros are shifted into the upper bits).                                                                                                                                                                                                                                                                         | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.SRAI     | c.srai rd', uimm[5:0]      | x[8 + rd'] = x[8 + rd'] >>s uimm[5:0]            | uimm[5] = 0                   | NONE                                                                                                                                                                                                                                                                           | performs an arithmetic right shift (sign bits are shifted into the upper bits).                                                                                                                                                                                                                                                                 | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.ANDI     | c.andi rd', imm[5:0]       | x[8 + rd'] = x[8 + rd'] & sext(imm[5:0])         | NONE                          | NONE                                                                                                                                                                                                                                                                           | computes the bitwise AND of the value in register rd', and the sign-extended 6-bit immediate, then writes the result to rd'.                                                                                                                                                                                                                    | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.ADD      | c.add rd, rs2              | x[rd] = x[rd] + x[rs2]                           | rd = x0 & rs2 = x0            | NONE                                                                                                                                                                                                                                                                           | adds the values in registers rd and rs2 and writes the result to register rd.                                                                                                                                                                                                                                                                   | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.MV       | c.mv rd, rs2               | x[rd] = x[rs2]                                   | rd = x0 & rs2 = x0            | NONE                                                                                                                                                                                                                                                                           | copies the value in register rs2 into register rd.                                                                                                                                                                                                                                                                                              | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.AND      | c.and rd', rs2'            | x[8 + rd'] = x[8 + rd'] & x[8 + rs2']            | NONE                          | NONE                                                                                                                                                                                                                                                                           | computes the bitwise AND of of the value in register rd', and register rs2', then writes the result to rd'.                                                                                                                                                                                                                                     | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.OR       | c.or rd', rs2'             | x[8 + rd'] = x[8 + rd'] | x[8 + rs2']            | NONE                          | NONE                                                                                                                                                                                                                                                                           | computes the bitwise OR of of the value in register rd', and register rs2', then writes the result to rd'.                                                                                                                                                                                                                                      | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.XOR      | c.and rd', rs2'            | x[8 + rd'] = x[8 + rd'] ^ x[8 + rs2']            | NONE                          | NONE                                                                                                                                                                                                                                                                           | computes the bitwise XOR of of the value in register rd', and register rs2', then writes the result to rd'.                                                                                                                                                                                                                                     | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.SUB      | c.sub rd', rs2'            | x[8 + rd'] = x[8 + rd'] - x[8 + rs2']            | NONE                          | NONE                                                                                                                                                                                                                                                                           | subtracts the value in registers rs2' from value in rd' and writes the result to register rd'.                                                                                                                                                                                                                                                  | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.EBREAK   | c.ebreak                   | RaiseException(Breakpoint)                       | NONE                          | Raise a Breakpoint exception.                                                                                                                                                                                                                                                  | cause control to be transferred back to the debugging environment.                                                                                                                                                                                                                                                                              | Integer Computational Instructions |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.J        | c.j imm[11:1]              | pc += sext(imm[11:1])                            | NONE                          | jumps to an unaligned address (4-byte or 2-byte boundary) will usually raise an exception.                                                                                                                                                                                     | performs an unconditional control transfer. The offset is sign-extended and added to the pc to form the jump target address.                                                                                                                                                                                                                    | Control Transfer Instructions      |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.JAL      | c.jal imm[11:1]            | x[1] = pc+2; pc += sext(imm[11:1])               | NONE                          | jumps to an unaligned address (4-byte or 2-byte boundary) will usually raise an exception.                                                                                                                                                                                     | performs the same operation as C.J, but additionally writes the address of the instruction following the jump (pc+2) to the link register, x1.                                                                                                                                                                                                  | Control Transfer Instructions      |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.JR       | c.jr rs1                   | pc = x[rs1]                                      | rs1 = x0                      | jumps to an unaligned address (4-byte or 2-byte boundary) will usually raise an exception.                                                                                                                                                                                     | performs an unconditional control transfer to the address in register rs1.                                                                                                                                                                                                                                                                      | Control Transfer Instructions      |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.JALR     | c.jalr rs1                 | t = pc+2; pc = x[rs1]; x[1] = t                  | rs1 = x0                      | jumps to an unaligned address (4-byte or 2-byte boundary) will usually raise an exception.                                                                                                                                                                                     | performs the same operation as C.JR, but additionally writes the address of the instruction following the jump (pc+2) to the link register, x1.                                                                                                                                                                                                 | Control Transfer Instructions      |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.BEQZ     | c.beqz rs1', imm[8:1]      | if (x[8+rs1'] == 0) pc += sext(imm[8:1])         | NONE                          | no instruction fetch misaligned exception is generated for a conditional branch that is not taken. An Instruction address misaligned exception is raised if the target address is not aligned on 4-byte or 2-byte boundary, because the core supports compressed instructions. | performs conditional control transfers. The offset is sign-extended and added to the pc to form the branch target address. C.BEQZ takes the branch if the value in register rs1' is zero.                                                                                                                                                       | Control Transfer Instructions      |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.BNEZ     | c.bnez rs1', imm[8:1]      | if (x[8+rs1'] != 0) pc += sext(imm[8:1])         | NONE                          | no instruction fetch misaligned exception is generated for a conditional branch that is not taken. An Instruction address misaligned exception is raised if the target address is not aligned on 4-byte or 2-byte boundary, because the core supports compressed instructions. | performs conditional control transfers. The offset is sign-extended and added to the pc to form the branch target address. C.BEQZ takes the branch if the value in register rs1' isn't zero.                                                                                                                                                    | Control Transfer Instructions      |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.LWSP     | c.lwsp rd, uimm(x2)        | x[rd] = M[x[2] + zext(uimm[7:2])][31:0]          | rd = x0                       | loads with a destination of x0 must still raise any exceptions, also an exception if the memory address isn't aligned (4-byte boundary).                                                                                                                                       | loads a 32-bit value from memory into register rd. It computes an effective address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2.                                                                                                                                                                                  | Load and Store Instructions        |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.SWSP     | c.swsp rd, uimm(x2)        | M[x[2] + zext(uimm[7:2])][31:0] = x[rs2]         | NONE                          | an exception raised if the memory address isn't aligned (4-byte boundary).                                                                                                                                                                                                     | stores a 32-bit value in register rs2 to memory. It computes an effective address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2.                                                                                                                                                                                    | Load and Store Instructions        |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.LW       | c.lw rd', uimm(rs1')       | x[8+rd'] = M[x[8+rs1'] + zext(uimm[6:2])][31:0]) | NONE                          | an exception raised if the memory address isn't aligned (4-byte boundary).                                                                                                                                                                                                     | loads a 32-bit value from memory into register rd'. It computes an effective address by adding the zero-extended offset, scaled by 4, to the base address in register rs1'.                                                                                                                                                                     | Load and Store Instructions        |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+
| C.SW       | c.sw rs2', uimm(rs1')      | M[x[8+rs1'] + zext(uimm[6:2])][31:0] = x[8+rs2'] | NONE                          | an exception raised if the memory address isn't aligned (4-byte boundary).                                                                                                                                                                                                     | stores a 32-bit value from memory into register rd'. It computes an effective address by adding the zero-extended offset, scaled by 4, to the base address in register rs1'.                                                                                                                                                                    | Load and Store Instructions        |
+------------+----------------------------+--------------------------------------------------+-------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------+

RV32Zicsr Control and Status Register Instructions
--------------------------------------------------


+--------+---------------------------+------------------------------------------------------------+------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------+
| Name   | Format                    | Pseudocode                                                 | Invalid_values   | Exception_raised                                                                                                                                                                                                       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Op Name                                |
+========+===========================+============================================================+==================+========================================================================================================================================================================================================================+===================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================+========================================+
| CSRRW  | csrrw rd, csr, rs1        | t = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t               | NONE             | Attempts to access a non-existent CSR raise an illegal instruction exception. Attempts to access a CSR without appropriate privilege level or to write a read-only register also raise illegal instruction exceptions. | Reads the old value of the CSR, zero-extends the value to 32 bits, then writes it to integer register rd. The initial value in rs1 is written to the CSR. If rd=x0, then the instruction shall not read the CSR and shall not cause any of the side-effects that might occur on a CSR read.                                                                                                                                                                                                                                                                                                                                                                                       | Control and Status Register Operations |
+--------+---------------------------+------------------------------------------------------------+------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------+
| CSRRS  | csrrs rd, csr, rs1        | t = CSRs[csr]; CSRs[csr] = t | x[rs1]; x[rd] = t           | NONE             | Attempts to access a non-existent CSR raise an illegal instruction exception. Attempts to access a CSR without appropriate privilege level or to write a read-only register also raise illegal instruction exceptions. | Reads the value of the CSR, zero-extends the value to 32 bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be set in the CSR. Any bit that is high in rs1 will cause the corresponding bit to be set in the CSR, if that CSR bit is writable. Other bits in the CSR are unaffected (though CSRs might have side effects when written). If rs1=x0, then the instruction will not write to the CSR at all, and so shall not cause any of the side effects that might otherwise occur on a CSR write, such as raising illegal instruction exceptions on accesses to read-only CSRs.     | Control and Status Register Operations |
+--------+---------------------------+------------------------------------------------------------+------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------+
| CSRRC  | csrrc rd, csr, rs1        | t = CSRs[csr]; CSRs[csr] = t & ∼x[rs1]; x[rd] = t          | NONE             | Attempts to access a non-existent CSR raise an illegal instruction exception. Attempts to access a CSR without appropriate privilege level or to write a read-only register also raise illegal instruction exceptions. | Reads the value of the CSR, zero-extends the value to 32 bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be cleared in the CSR. Any bit that is high in rs1 will cause the corresponding bit to be set in the CSR, if that CSR bit is writable. Other bits in the CSR are unaffected (though CSRs might have side effects when written). If rs1=x0, then the instruction will not write to the CSR at all, and so shall not cause any of the side effects that might otherwise occur on a CSR write, such as raising illegal instruction exceptions on accesses to read-only CSRs. | Control and Status Register Operations |
+--------+---------------------------+------------------------------------------------------------+------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------+
| CSRRWI | csrrwi rd, csr, uimm[4:0] | x[rd] = CSRs[csr]; CSRs[csr] = zext(uimm[4:0])             | NONE             | Attempts to access a non-existent CSR raise an illegal instruction exception. Attempts to access a CSR without appropriate privilege level or to write a read-only register also raise illegal instruction exceptions. | Reads the old value of the CSR, zero-extends the value to 32 bits, then writes it to integer register rd. The zero-extends immediate is written to the CSR. If rd=x0, then the instruction shall not read the CSR and shall not cause any of the side-effects that might occur on a CSR read.                                                                                                                                                                                                                                                                                                                                                                                     | Control and Status Register Operations |
+--------+---------------------------+------------------------------------------------------------+------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------+
| CSRRSI | csrrsi rd, csr, uimm[4:0] | t = CSRs[csr]; CSRs[csr] = t | zext(uimm[4:0]); x[rd] = t  | NONE             | Attempts to access a non-existent CSR raise an illegal instruction exception. Attempts to access a CSR without appropriate privilege level or to write a read-only register also raise illegal instruction exceptions. | Reads the value of the CSR, zero-extends the value to 32 bits, and writes it to integer register rd. The zero-extends immediate value is treated as a bit mask that specifies bit positions to be set in the CSR. Any bit that is high in zero-extends immediate will cause the corresponding bit to be set in the CSR, if that CSR bit is writable. Other bits in the CSR are unaffected (though CSRs might have side effects when written). If the uimm[4:0] field is zero, then these instructions will not write to the CSR, and shall not cause any of the side effects that might otherwise occur on a CSR write.                                                           | Control and Status Register Operations |
+--------+---------------------------+------------------------------------------------------------+------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------+
| CSRRCI | csrrci rd, csr, uimm[4:0] | t = CSRs[csr]; CSRs[csr] = t & ∼zext(uimm[4:0]); x[rd] = t | NONE             | Attempts to access a non-existent CSR raise an illegal instruction exception. Attempts to access a CSR without appropriate privilege level or to write a read-only register also raise illegal instruction exceptions. | Reads the value of the CSR, zero-extends the value to 32 bits, and writes it to integer register rd. The zero-extends immediate value is treated as a bit mask that specifies bit positions to be cleared in the CSR. Any bit that is high in zero-extends immediate will cause the corresponding bit to be set in the CSR, if that CSR bit is writable. Other bits in the CSR are unaffected (though CSRs might have side effects when written). If the uimm[4:0] field is zero, then these instructions will not write to the CSR, and shall not cause any of the side effects that might otherwise occur on a CSR write.                                                       | Control and Status Register Operations |
+--------+---------------------------+------------------------------------------------------------+------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------+

RV32Zcb Code Size Reduction Instructions
----------------------------------------


+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| Name     | Format                | Pseudocode                                           | Invalid_values   | Exception_raised                                                           | Description                                                                                                                                                                                                                                                                                  | Op Name                        |
+==========+=======================+======================================================+==================+============================================================================+==============================================================================================================================================================================================================================================================================================+================================+
| C.ZEXT.B | c.zext.b rd'          | x[8 + rd'] = zext(x[8 + rd'][7:0])                   | NONE             | NONE                                                                       | This instruction takes a single source/destination operand. It zero-extends the least-significant byte of the operand by inserting zeros into all of the bits more significant than 7.                                                                                                       | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| C.SEXT.B | c.sext.b rd'          | x[8 + rd'] = sext(x[8 + rd'][7:0])                   | NONE             | NONE                                                                       | This instruction takes a single source/destination operand. It sign-extends the least-significant byte in the operand by copying the most-significant bit in the byte (i.e., bit 7) to all of the more-significant bits. It also requires Bit-Manipulation (Zbb) extension support.          | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| C.ZEXT.H | c.zext.h rd'          | x[8 + rd'] = zext(x[8 + rd'][15:0])                  | NONE             | NONE                                                                       | This instruction takes a single source/destination operand. It zero-extends the least-significant halfword of the operand by inserting zeros into all of the bits more significant than 15. It also requires Bit-Manipulation (Zbb) extension support.                                       | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| C.SEXT.H | c.sext.h rd'          | x[8 + rd'] = sext(x[8 + rd'][15:0])                  | NONE             | NONE                                                                       | This instruction takes a single source/destination operand. It sign-extends the least-significant halfword in the operand by copying the most-significant bit in the halfword (i.e., bit 15) to all of the more-significant bits. It also requires Bit-Manipulation (Zbb) extension support. | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| C.NOT    | c.not rd'             | x[8 + rd'] = x[8 + rd'] ^ -1                         | NONE             | NONE                                                                       | This instruction takes the one’s complement of rd'/rs1' and writes the result to the same register.                                                                                                                                                                                          | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| C.MUL    | c.mul rd', rs2'       | x[8 + rd'] = (x[8 + rd'] * x[8 + rs2'])[31:0]        | NONE             | NONE                                                                       | performs a 32-bit × 32-bit multiplication and places the lower 32 bits in the destination register (Both rd' and rs2' treated as signed numbers). It also requires M extension support.                                                                                                      | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| C.LHU    | c.lhu rd', uimm(rs1') | x[8+rd'] = zext(M[x[8+rs1'] + zext(uimm[1])][15:0])  | NONE             | an exception raised if the memory address isn't aligned (2-byte boundary). | This instruction loads a halfword from the memory address formed by adding rs1' to the zero extended immediate uimm. The resulting halfword is zero extended and is written to rd'.                                                                                                          | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| C.LH     | c.lh rd', uimm(rs1')  | x[8+rd'] = sext(M[x[8+rs1'] + zext(uimm[1])][15:0])  | NONE             | an exception raised if the memory address isn't aligned (2-byte boundary). | This instruction loads a halfword from the memory address formed by adding rs1' to the zero extended immediate uimm. The resulting halfword is sign extended and is written to rd'.                                                                                                          | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| C.LBU    | c.lbu rd', uimm(rs1') | x[8+rd'] = zext(M[x[8+rs1'] + zext(uimm[1:0])][7:0]) | NONE             | NONE                                                                       | This instruction loads a byte from the memory address formed by adding rs1' to the zero extended immediate uimm. The resulting byte is zero extended and is written to rd'.                                                                                                                  | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| C.SH     | c.sh rs2', uimm(rs1') | M[x[8+rs1'] + zext(uimm[1])][15:0] = x[8+rs2']       | NONE             | an exception raised if the memory address isn't aligned (2-byte boundary). | This instruction stores the least significant halfword of rs2' to the memory address formed by adding rs1' to the zero extended immediate uimm.                                                                                                                                              | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+
| C.SB     | c.sb rs2', uimm(rs1') | M[x[8+rs1'] + zext(uimm[1:0])][7:0] = x[8+rs2']      | NONE             | NONE                                                                       | This instruction stores the least significant byte of rs2' to the memory address formed by adding rs1' to the zero extended immediate uimm.                                                                                                                                                  | Code Size Reduction Operations |
+----------+-----------------------+------------------------------------------------------+------------------+----------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------+

RVZba Address generation instructions
-------------------------------------


+-----------+------------------------+------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------+
| Name      | Format                 | Pseudocode                               | Invalid_values   | Exception_raised   | Description                                                                                                                                                                                                               | Op Name                         |
+===========+========================+==========================================+==================+====================+===========================================================================================================================================================================================================================+=================================+
| ADD.UW    | add.uw rd, rs1, rs2    | X(rd) = rs2 + EXTZ(X(rs1)[31..0])        | NONE             | NONE               | This instruction performs an XLEN-wide addition between rs2 and the zero-extended least-significant word of rs1.                                                                                                          | Address generation instructions |
+-----------+------------------------+------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------+
| SH1ADD    | sh1add rd, rs1, rs2    | X(rd) = X(rs2) + (X(rs1) << 1)           | NONE             | NONE               | This instruction shifts rs1 to the left by 1 bit and adds it to rs2.                                                                                                                                                      | Address generation instructions |
+-----------+------------------------+------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------+
| SH1ADD.UW | sh1add.uw rd, rs1, rs2 | X(rd) = rs2 + (EXTZ(X(rs1)[31..0]) << 1) | NONE             | NONE               | This instruction performs an XLEN-wide addition of two addends. The first addend is rs2. The second addend is the unsigned value formed by extracting the least-significant word of rs1 and shifting it left by 1 place.  | Address generation instructions |
+-----------+------------------------+------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------+
| SH2ADD    | sh2add rd, rs1, rs2    | X(rd) = X(rs2) + (X(rs1) << 2)           | NONE             | NONE               | This instruction shifts rs1 to the left by 2 bit and adds it to rs2.                                                                                                                                                      | Address generation instructions |
+-----------+------------------------+------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------+
| SH2ADD.UW | sh2add.uw rd, rs1, rs2 | X(rd) = rs2 + (EXTZ(X(rs1)[31..0]) << 2) | NONE             | NONE               | This instruction performs an XLEN-wide addition of two addends. The first addend is rs2. The second addend is the unsigned value formed by extracting the least-significant word of rs1 and shifting it left by 2 places. | Address generation instructions |
+-----------+------------------------+------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------+
| SH3ADD    | sh3add rd, rs1, rs2    | X(rd) = X(rs2) + (X(rs1) << 3)           | NONE             | NONE               | This instruction shifts rs1 to the left by 3 bit and adds it to rs2.                                                                                                                                                      | Address generation instructions |
+-----------+------------------------+------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------+
| SH3ADD.UW | sh3add.uw rd, rs1, rs2 | X(rd) = rs2 + (EXTZ(X(rs1)[31..0]) << 3) | NONE             | NONE               | This instruction performs an XLEN-wide addition of two addends. The first addend is rs2. The second addend is the unsigned value formed by extracting the least-significant word of rs1 and shifting it left by 3 places. | Address generation instructions |
+-----------+------------------------+------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------+
| SLLI.UW   | slli.uw rd, rs1, imm   | X(rd) = (EXTZ(X(rs)[31..0]) << imm)      | NONE             | NONE               | This instruction takes the least-significant word of rs1, zero-extends it, and shifts it left by the immediate.                                                                                                           | Address generation instructions |
+-----------+------------------------+------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------+

RVZbb Basic bit-manipulation
----------------------------


+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| Name   | Format               | Pseudocode                                                   | Invalid_values   | Exception_raised   | Description                                                                                                                                                         | Op Name                          |
+========+======================+==============================================================+==================+====================+=====================================================================================================================================================================+==================================+
| ANDN   | andn rd, rs1, rs2    | X(rd) = X(rs1) & ~X(rs2)                                     | NONE             | NONE               | Performs bitwise AND operation between rs1 and bitwise inversion of rs2.                                                                                            | Logical_with_negate              |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| ORN    | orn rd, rs1, rs2     | X(rd) = X(rs1) | ~X(rs2)                                     | NONE             | NONE               | Performs bitwise OR operation between rs1 and bitwise inversion of rs2.                                                                                             | Logical_with_negate              |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| XNOR   | xnor rd, rs1, rs2    | X(rd) = ~(X(rs1) ^ X(rs2))                                   | NONE             | NONE               | Performs bitwise XOR operation between rs1 and rs2, then complements the result.                                                                                    | Logical_with_negate              |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| CLZ    | clz rd, rs           | if [x[i]] == 1 then return(i) else return -1                 | NONE             | NONE               | Counts leading zero bits in rs.                                                                                                                                     | Count_leading_trailing_zero_bits |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| CTZ    | ctz rd, rs           | if [x[i]] == 1 then return(i) else return xlen;              | NONE             | NONE               | Counts trailing zero bits in rs.                                                                                                                                    | Count_leading_trailing_zero_bits |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| CLZW   | clzw rd, rs          | if [x[i]] == 1 then return(i) else return -1                 | NONE             | NONE               | Counts leading zero bits in the least-significant word of rs.                                                                                                       | Count_leading_trailing_zero_bits |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| CTZW   | ctzw rd, rs          | if [x[i]] == 1 then return(i) else return 32;                | NONE             | NONE               | Counts trailing zero bits in the least-significant word of rs.                                                                                                      | Count_leading_trailing_zero_bits |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| CPOP   | cpop rd, rs          | if rs[i] == 1 then bitcount = bitcount + 1 else ()           | NONE             | NONE               | Counts set bits in rs.                                                                                                                                              | Count_population                 |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| CPOPW  | cpopw rd, rs         | if rs[i] == 0b1 then bitcount = bitcount + 1 else ()         | NONE             | NONE               | Counts set bits in the least-significant word of rs.                                                                                                                | Count_population                 |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| MAX    | max rd, rs1, rs2     | if rs1_val <_s rs2_val then rs2_val else rs1_val             | NONE             | NONE               | Returns the larger of two signed integers.                                                                                                                          | Integer_minimum_maximum          |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| MAXU   | maxu rd, rs1, rs2    | if rs1_val <_u rs2_val then rs2_val else rs1_val             | NONE             | NONE               | Returns the larger of two unsigned integers.                                                                                                                        | Integer_minimum_maximum          |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| MIN    | min rd, rs1, rs2     | if rs1_val <_s rs2_val then rs1_val else rs2_val             | NONE             | NONE               | Returns the smaller of two signed integers.                                                                                                                         | Integer_minimum_maximum          |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| MINU   | minu rd, rs1, rs2    | if rs1_val <_u rs2_val then rs1_val else rs2_val             | NONE             | NONE               | Returns the smaller of two unsigned integers.                                                                                                                       | Integer_minimum_maximum          |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| SEXT.B | sext.b rd, rs        | X(rd) = EXTS(X(rs)[7..0])                                    | NONE             | NONE               | Sign-extends the least-significant byte in the source to XLEN.                                                                                                      | Sign_and_zero_extension          |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| SEXT.H | sext.h rd, rs        | X(rd) = EXTS(X(rs)[15..0])                                   | NONE             | NONE               | Sign-extends the least-significant halfword in rs to XLEN.                                                                                                          | Sign_and_zero_extension          |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| ZEXT.H | zext.h rd, rs        | X(rd) = EXTZ(X(rs)[15..0])                                   | NONE             | NONE               | Zero-extends the least-significant halfword of the source to XLEN.                                                                                                  | Sign_and_zero_extension          |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| ROL    | rol rd, rs1, rs2     | (X(rs1) << log2(XLEN)) | (X(rs1) >> (xlen - log2(XLEN)))     | NONE             | NONE               | Performs a rotate left of rs1 by the amount in least-significant log2(XLEN) bits of rs2.                                                                            | Bitwise_rotation                 |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| ROR    | ror rd, rs1, rs2     | (X(rs1) >> log2(XLEN)) | (X(rs1) << (xlen - log2(XLEN)))     | NONE             | NONE               | Performs a rotate right of rs1 by the amount in least-significant log2(XLEN) bits of rs2.                                                                           | Bitwise_rotation                 |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| RORI   | rori rd, rs1, shamt  | (X(rs1) >> log2(XLEN)) | (X(rs1) << (xlen - log2(XLEN)))     | NONE             | NONE               | Performs a rotate right of rs1 by the amount in least-significant log2(XLEN) bits of shamt.                                                                         | Bitwise_rotation                 |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| ROLW   | rolw rd, rs1, rs2    | EXTS((rs1 << X(rs2)[4..0]) | (rs1 >> (32 - X(rs2)[4..0])))   | NONE             | NONE               | Performs a rotate left on the least-significant word of rs1 by the amount in least-significant 5 bits of rs2.                                                       | Bitwise_rotation                 |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| RORIW  | roriw rd, rs1, shamt | (rs1_data >> shamt[4..0]) | (rs1_data << (32 - shamt[4..0])) | NONE             | NONE               | Performs a rotate right on the least-significant word of rs1 by the amount in least-significant log2(XLEN) bits of shamt.                                           | Bitwise_rotation                 |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| RORW   | rorw rd, rs1, rs2    | (rs1 >> X(rs2)[4..0]) | (rs1 << (32 - X(rs2)[4..0]))         | NONE             | NONE               | Performs a rotate right on the least-significant word of rs1 by the amount in least-significant 5 bits of rs2.                                                      | Bitwise_rotation                 |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| ORC.b  | orc.b rd, rs         | if { input[(i + 7)..i] == 0 then 0b00000000 else 0b11111111  | NONE             | NONE               | Sets the bits of each byte in rd to all zeros if no bit within the respective byte of rs is set, or to all ones if any bit within the respective byte of rs is set. | OR_Combine                       |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+
| REV8   | rev8 rd, rs          | output[i..(i + 7)] = input[(j - 7)..j]                       | NONE             | NONE               | Reverses the order of the bytes in rs.                                                                                                                              | Byte_reverse                     |
+--------+----------------------+--------------------------------------------------------------+------------------+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------+

RVZbc Carry-less multiplication
-------------------------------


+--------+---------------------+------------------------------------------------------------------------------------------+------------------+--------------------+------------------------------------------------------------------------+--------------------------------------+
| Name   | Format              | Pseudocode                                                                               | Invalid_values   | Exception_raised   | Description                                                            | Op Name                              |
+========+=====================+==========================================================================================+==================+====================+========================================================================+======================================+
| CLMUL  | clmul rd, rs1, rs2  | foreach (i from 1 to xlen by 1) {                                                        | NONE             | NONE               | clmul produces the lower half of the 2.XLEN carry-less product.        | Carry-less multiplication Operations |
|        |                     |   output = if ((rs2 >> i) & 1) then output ^ (rs1 << i); else output;                    |                  |                    |                                                                        |                                      |
|        |                     | }                                                                                        |                  |                    |                                                                        |                                      |
+--------+---------------------+------------------------------------------------------------------------------------------+------------------+--------------------+------------------------------------------------------------------------+--------------------------------------+
| CLMULH | clmulh rd, rs1, rs2 | foreach (i from 1 to xlen by 1) {                                                        | NONE             | NONE               | clmulh produces the upper half of the 2.XLEN carry-less product.       | Carry-less multiplication Operations |
|        |                     |   output = if ((rs2_val >> i) & 1) then output ^ (rs1_val >> (xlen - i)) else output     |                  |                    |                                                                        |                                      |
|        |                     | }                                                                                        |                  |                    |                                                                        |                                      |
+--------+---------------------+------------------------------------------------------------------------------------------+------------------+--------------------+------------------------------------------------------------------------+--------------------------------------+
| CLMULR | clmulr rd, rs1, rs2 | foreach (i from 0 to (xlen - 1) by 1) {                                                  | NONE             | NONE               | clmulr produces bits 2.XLEN-2:XLEN-1 of the 2.XLEN carry-less product. | Carry-less multiplication Operations |
|        |                     |   output = if ((rs2_val >> i) & 1) then output ^ (rs1_val >> (xlen - i - 1)) else output |                  |                    |                                                                        |                                      |
|        |                     | }                                                                                        |                  |                    |                                                                        |                                      |
+--------+---------------------+------------------------------------------------------------------------------------------+------------------+--------------------+------------------------------------------------------------------------+--------------------------------------+

RVZbs Single bit Instructions
-----------------------------


+--------+----------------------+------------------------------------------------+------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| Name   | Format               | Pseudocode                                     | Invalid_values   | Exception_raised   | Description                                                                                                                                                                                                           | Op Name               |
+========+======================+================================================+==================+====================+=======================================================================================================================================================================================================================+=======================+
| BCLR   | bclr rd, rs1, rs2    | X(rd) = X(rs1) & ~(1 << (X(rs2) & (XLEN - 1))) | NONE             | NONE               | This instruction returns rs1 with a single bit cleared at the index specified in rs2. The index is read from the lower log2(XLEN) bits of rs2.                                                                        | Single_bit_Operations |
+--------+----------------------+------------------------------------------------+------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| BCLRI  | bclri rd, rs1, shamt | X(rd) = X(rs1) & ~(1 << (shamt & (XLEN - 1)))  | NONE             | NONE               | This instruction returns rs1 with a single bit cleared at the index specified in shamt. The index is read from the lower log2(XLEN) bits of shamt. For RV32, the encodings corresponding to shamt[5]=1 are reserved.  | Single_bit_Operations |
+--------+----------------------+------------------------------------------------+------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| BEXT   | bext rd, rs1, rs2    | X(rd) = (X(rs1) >> (X(rs2) & (XLEN - 1))) & 1  | NONE             | NONE               | This instruction returns a single bit extracted from rs1 at the index specified in rs2. The index is read from the lower log2(XLEN) bits of rs2.                                                                      | Single_bit_Operations |
+--------+----------------------+------------------------------------------------+------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| BEXTI  | bexti rd, rs1, shamt | X(rd) = (X(rs1) >> (shamt & (XLEN - 1))) & 1   | NONE             | NONE               | This instruction returns a single bit extracted from rs1 at the index specified in rs2. The index is read from the lower log2(XLEN) bits of shamt. For RV32, the encodings corresponding to shamt[5]=1 are reserved.  | Single_bit_Operations |
+--------+----------------------+------------------------------------------------+------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| BINV   | binv rd, rs1, rs2    | X(rd) = X(rs1) ^ (1 << (X(rs2) & (XLEN - 1)))  | NONE             | NONE               | This instruction returns rs1 with a single bit inverted at the index specified in rs2. The index is read from the lower log2(XLEN) bits of rs2.                                                                       | Single_bit_Operations |
+--------+----------------------+------------------------------------------------+------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| BINVI  | binvi rd, rs1, shamt | X(rd) = X(rs1) ^ (1 << (shamt & (XLEN - 1)))   | NONE             | NONE               | This instruction returns rs1 with a single bit inverted at the index specified in shamt. The index is read from the lower log2(XLEN) bits of shamt. For RV32, the encodings corresponding to shamt[5]=1 are reserved. | Single_bit_Operations |
+--------+----------------------+------------------------------------------------+------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| BSET   | bset rd, rs1, rs2    | X(rd) = X(rs1) | (1 << (X(rs2) & (XLEN - 1)))  | NONE             | NONE               | This instruction returns rs1 with a single bit set at the index specified in rs2. The index is read from the lower log2(XLEN) bits of rs2.                                                                            | Single_bit_Operations |
+--------+----------------------+------------------------------------------------+------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
| BSETI  | bseti rd, rs1, shamt | X(rd) = X(rs1) | (1 << (shamt & (XLEN - 1)))   | NONE             | NONE               | This instruction returns rs1 with a single bit set at the index specified in shamt. The index is read from the lower log2(XLEN) bits of shamt. For RV32, the encodings corresponding to shamt[5]=1 are reserved.      | Single_bit_Operations |
+--------+----------------------+------------------------------------------------+------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------+
