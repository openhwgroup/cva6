..
   Copyright (c) 2022 Jade Design Automation

   SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1

.. _cv32a6_control_status_registers:


CV32A6_CSR programmers view
===========================

CV32A6 does not implement all control and status registers specified in the RISC-V privileged specifications,
but is limited to the registers that were needed for a 32-bit application core.
This keeps the footprint of the core as low as possible and avoid any overhead that we do not explicitly need.

The **Parameter** column identifies those CSRs that are dependent on the value
of specific compile/synthesis parameters. If these parameters are not set as
indicated in **Control and Status Register Map** then the associated CSR is not implemented.  If the
parameter column is empty then the associated CSR is always implemented.

The **Privilege** column indicates the access mode of a CSR.  The first letter
indicates the lowest privilege level required to access the CSR.  Attempts to
access a CSR with a higher privilege level than the core is currently running
in will throw an illegal instruction exception.  This is largely a moot point
for the CV32E40P as it only supports machine and debug modes.  The remaining
letters indicate the read and/or write behavior of the CSR when accessed by
the indicated or higher privilege level:

* **RW**: CSR is **read-write**.  That is, CSR instructions (e.g. csrrw) may
  write any value and that value will be returned on a subsequent read (unless
  a side-effect causes the core to change the CSR value).

* **RO**: CSR is **read-only**.  Writes by CSR instructions raise an illegal
  instruction exception.

Writes of a non-supported value to **WLRL** bitfields of a **RW** CSR do not result in an illegal
instruction exception. The exact bitfield access types, e.g. **WLRL** or **WARL**, can be found in the RISC-V
privileged specification.

Reads or writes to a CSR that is not implemented will result in an illegal instruction exception.

Any illegal instruction exception raised by CSR access is precise.
For instance, reading and writing to a read-only CSR will not update the destination register.

.. tip::
  This section was auto-generated by **Register Manager** from `Jade Design Automation <https://jade-da.com/>`_. |logo|

  .. |logo| image:: ./images/jade_design_automation_logo.png


Register Summary
----------------
.. csv-table::
   :widths: auto
   :align: left
   :header: "Name", "Address Offset", "Width", "Access Type", "Reset Value", "Display Name"

   "``fflags``", "0x1", "32", "RW", "0x00000000", "Floating-Point Accrued Exceptions"
   "``frm``", "0x2", "32", "RW", "0x00000000", "Floating-Point Dynamic Rounding Mode"
   "``fcsr``", "0x3", "32", "RW", "0x00000000", "Floating-Point Control and Status Register"
   "``sstatus``", "0x100", "32", "RW", "0x00000000", "Supervisor Status"
   "``sie``", "0x104", "32", "RW", "0x00000000", "Supervisor Interrupt Enable"
   "``stvec``", "0x105", "32", "RW", "0x00000000", "Supervisor Trap Vector Base Address"
   "``scounteren``", "0x106", "32", "RW", "0x00000000", "Supervisor Counter Enable"
   "``sscratch``", "0x140", "32", "RW", "0x00000000", "Supervisor Scratch"
   "``sepc``", "0x141", "32", "RW", "0x00000000", "Supervisor Exception Program Counter"
   "``scause``", "0x142", "32", "RW", "0x00000000", "Supervisor Cause"
   "``stval``", "0x143", "32", "RW", "0x00000000", "Supervisor Trap Value"
   "``sip``", "0x144", "32", "RW", "0x00000000", "Supervisor Interrupt Pending"
   "``satp``", "0x180", "32", "RW", "0x00000000", "Supervisor Address Translation and Protection"
   "``mstatus``", "0x300", "32", "RW", "0x00000000", "Machine Status"
   "``misa``", "0x301", "32", "RW", "0x00000000", "Machine ISA"
   "``medeleg``", "0x302", "32", "RW", "0x00000000", "Machine Exception Delegation"
   "``mideleg``", "0x303", "32", "RW", "0x00000000", "Machine Interrupt Delegation"
   "``mie``", "0x304", "32", "RW", "0x00000000", "Machine Interrupt Enable"
   "``mtvec``", "0x305", "32", "RW", "0x00000000", "Machine Trap Vector"
   "``mcountern``", "0x306", "32", "RW", "0x00000000", "Machine Counter Enable"
   "``hpmevent[6]``", "0x323 [+ i*0x1]", "32", "RW", "0x00000000", "Hardware Performance-Monitoring Event Selector"
   "``mscratch``", "0x340", "32", "RW", "0x00000000", "Machine Scratch"
   "``mepc``", "0x341", "32", "RW", "0x00000000", "Machine Exception Program Counter"
   "``mcause``", "0x342", "32", "RW", "0x00000000", "Machine Cause"
   "``mtval``", "0x343", "32", "RW", "0x00000000", "Machine Trap Value"
   "``mip``", "0x344", "32", "RW", "0x00000000", "Machine Interrupt Pending"
   "``pmpcfg0``", "0x3A0", "32", "RW", "0x00000000", "Physical Memory Protection Config 0"
   "``pmpcfg1``", "0x3A1", "32", "RW", "0x00000000", "Physical Memory Protection Config 1"
   "``pmpcfg2``", "0x3A2", "32", "RW", "0x00000000", "Physical Memory Protection Config 2"
   "``pmpcfg3``", "0x3A3", "32", "RW", "0x00000000", "Physical Memory Protection Config 3"
   "``pmpaddr[16]``", "0x3B0 [+ i*0x1]", "32", "RW", "0x00000000", "Physical Memory Protection Address"
   "``icache``", "0x700", "32", "RW", "0x00000001", "Instruction Cache"
   "``dcache``", "0x701", "32", "RW", "0x00000001", "Data Cache"
   "``tselect``", "0x7A0", "32", "RW", "0x00000000", "Trigger Select"
   "``tdata1``", "0x7A1", "32", "RW", "0x00000000", "Trigger Data 1"
   "``tdata2``", "0x7A2", "32", "RW", "0x00000000", "Trigger Data 2"
   "``tdata3``", "0x7A3", "32", "RW", "0x00000000", "Trigger Data 3"
   "``tinfo``", "0x7A4", "32", "RO", "0x00000000", "Trigger Info"
   "``dcsr``", "0x7B0", "32", "RW", "0x00000000", "Debug Control and Status"
   "``dpc``", "0x7B1", "32", "RW", "0x00000000", "Debug PC"
   "``dscratch[2]``", "0x7B2 [+ i*0x1]", "32", "RW", "0x00000000", "Debug Scratch Register"
   "``ftran``", "0x800", "32", "RW", "0x00000000", ""
   "``mcycle``", "0xB00", "32", "RW", "0x00000000", "M-mode Cycle counter"
   "``minstret``", "0xB02", "32", "RW", "0x00000000", "Machine Instruction Retired counter"
   "``ml1_icache_miss``", "0xB03", "32", "RW", "0x00000000", "L1 Inst Cache Miss"
   "``ml1_dcache_miss``", "0xB04", "32", "RW", "0x00000000", "L1 Data Cache Miss"
   "``mitlb_miss``", "0xB05", "32", "RW", "0x00000000", "ITLB Miss"
   "``mdtlb_miss``", "0xB06", "32", "RW", "0x00000000", "DTLB Miss"
   "``mload``", "0xB07", "32", "RW", "0x00000000", "Loads"
   "``mstore``", "0xB08", "32", "RW", "0x00000000", "Stores"
   "``mexception``", "0xB09", "32", "RW", "0x00000000", "Taken Exceptions"
   "``mexception_ret``", "0xB0A", "32", "RW", "0x00000000", "Exception Return"
   "``mbranch_jump``", "0xB0B", "32", "RW", "0x00000000", "Software Change of PC"
   "``mcall``", "0xB0C", "32", "RW", "0x00000000", "Procedure Call"
   "``mret``", "0xB0D", "32", "RW", "0x00000000", "Procedure Return"
   "``mmis_predict``", "0xB0E", "32", "RW", "0x00000000", "Branch mis-predicted"
   "``msb_full``", "0xB0F", "32", "RW", "0x00000000", "Scoreboard Full"
   "``mif_empty``", "0xB10", "32", "RW", "0x00000000", "Instruction Fetch Queue Empty"
   "``mcycleh``", "0xB80", "32", "RW", "0x00000000", "Upper 32-bits of M-mode Cycle counter"
   "``minstreth``", "0xB82", "32", "RW", "0x00000000", "Upper 32-bits of Machine Instruction Retired counter"
   "``mhpmcounterh[6]``", "0xB83 [+ i*0x1]", "32", "RW", "0x00000000", "Upper 32-bits of Machine Hardware Performance Monitoring Counter"
   "``cycle``", "0xC00", "32", "RO", "0x00000000", "Cycle counter"
   "``time``", "0xC01", "32", "RO", "0x00000000", "Timer"
   "``instret``", "0xC02", "32", "RO", "0x00000000", "Instruction Retired counter"
   "``l1_icache_miss``", "0xC03", "32", "RO", "0x00000000", "L1 Inst Cache Miss"
   "``l1_dcache_miss``", "0xC04", "32", "RO", "0x00000000", "L1 Data Cache Miss"
   "``itlb_miss``", "0xC05", "32", "RO", "0x00000000", "ITLB Miss"
   "``dtlb_miss``", "0xC06", "32", "RO", "0x00000000", "DTLB Miss"
   "``load``", "0xC07", "32", "RO", "0x00000000", "Loads"
   "``store``", "0xC08", "32", "RO", "0x00000000", "Stores"
   "``exception``", "0xC09", "32", "RO", "0x00000000", "Taken Exceptions"
   "``exception_ret``", "0xC0A", "32", "RO", "0x00000000", "Exception Return"
   "``branch_jump``", "0xC0B", "32", "RO", "0x00000000", "Software Change of PC"
   "``call``", "0xC0C", "32", "RO", "0x00000000", "Procedure Call"
   "``ret``", "0xC0D", "32", "RO", "0x00000000", "Procedure Return"
   "``mis_predict``", "0xC0E", "32", "RO", "0x00000000", "Branch mis-predicted"
   "``sb_full``", "0xC0F", "32", "RO", "0x00000000", "Scoreboard Full"
   "``if_empty``", "0xC10", "32", "RO", "0x00000000", "Instruction Fetch Queue Empty"
   "``cycleh``", "0xC80", "32", "RO", "0x00000000", "Upper 32-bits of Cycle counter"
   "``timeh``", "0xC81", "32", "RO", "0x00000000", "Upper 32-bit of Timer"
   "``instreth``", "0xC82", "32", "RO", "0x00000000", "Upper 32-bits of Instruction Retired counter"
   "``mvendorid``", "0xF11", "32", "RO", "0x00000000", "Machine Vendor ID"
   "``marchid``", "0xF12", "32", "RO", "0x00000003", "Machine Architecture ID"
   "``mimpid``", "0xF13", "32", "RO", "0x00000000", "Machine Implementation ID"
   "``mhartid``", "0xF14", "32", "RO", "0x00000000", "Machine Hardware Thread ID"

Register Descriptions
---------------------

Floating-Point Accrued Exceptions (``fflags``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x1
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The fields within the ``fcsr`` can also be accessed individually through different CSR addresses, and separate assembler pseudoinstructions are defined for these accesses. The FRRM instruction reads the Rounding Mode field ``frm`` and copies it into the least-significant three bits of integer register *rd*, with zero in all other bits. FSRM swaps the value in frm by copying the original value into integer register *rd*, and then writing a new value obtained from the three least-significant bits of integer register *rs1* into ``frm``. FRFLAGS and FSFLAGS are defined analogously for the Accrued Exception Flags field ``fflags``.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:5]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[4]", "``NV``", "Invalid Operation", "RW", "0b0"
   "[3]", "``DZ``", "Divide by Zero", "RW", "0b0"
   "[2]", "``OF``", "Overflow", "RW", "0b0"
   "[1]", "``UF``", "Underflow", "RW", "0b0"
   "[0]", "``NX``", "Inexact", "RW", "0b0"

:Invalid Operation (``NV``): The accrued exception flags indicate the exception conditions that have arisen on any floating-point arithmetic instruction since the field was last reset by software. The base RISC-V ISA does not support generating a trap on the setting of a floating-point exception flag.

:Divide by Zero (``DZ``): The accrued exception flags indicate the exception conditions that have arisen on any floating-point arithmetic instruction since the field was last reset by software. The base RISC-V ISA does not support generating a trap on the setting of a floating-point exception flag.

:Overflow (``OF``): The accrued exception flags indicate the exception conditions that have arisen on any floating-point arithmetic instruction since the field was last reset by software. The base RISC-V ISA does not support generating a trap on the setting of a floating-point exception flag.

:Underflow (``UF``): The accrued exception flags indicate the exception conditions that have arisen on any floating-point arithmetic instruction since the field was last reset by software. The base RISC-V ISA does not support generating a trap on the setting of a floating-point exception flag.

:Inexact (``NX``): The accrued exception flags indicate the exception conditions that have arisen on any floating-point arithmetic instruction since the field was last reset by software. The base RISC-V ISA does not support generating a trap on the setting of a floating-point exception flag.


Floating-Point Dynamic Rounding Mode (``frm``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x2
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The fields within the ``fcsr`` can also be accessed individually through different CSR addresses, and separate assembler pseudoinstructions are defined for these accesses. The FRRM instruction reads the Rounding Mode field ``frm`` and copies it into the least-significant three bits of integer register *rd*, with zero in all other bits. FSRM swaps the value in frm by copying the original value into integer register *rd*, and then writing a new value obtained from the three least-significant bits of integer register *rs1* into ``frm``. FRFLAGS and FSFLAGS are defined analogously for the Accrued Exception Flags field ``fflags``.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:3]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[2:0]", "``FRM``", "Floating-Point Rounding Mode", "RW", "0b0"

:Floating-Point Rounding Mode (``FRM``): Floating-point operations use either a static rounding mode encoded in the instruction, or a dynamic rounding mode held in ``frm``. Rounding modes are encoded as shown in the enumerated value. A value of 111 in
    the instruction’s *rm* field selects the dynamic rounding mode held in ``frm``. If ``frm`` is set to an invalid value (101–111), any subsequent attempt to execute a floating-point operation with a dynamic rounding mode will raise an illegal instruction exception. Some instructions, including widening conversions, have the *rm* field but are nevertheless unaffected by the rounding mode; software should set their *rm* field to RNE (000).

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b000", "RNE", "Round to Nearest, ties to Even"
       "0b001", "RTZ", "Round towards Zero"
       "0b010", "RDN", "Round Down"
       "0b011", "RUP", "Round Up"
       "0b100", "RMM", "Round to Nearest, ties to Max Magnitude"
       "0b101 - 0b110", "INVALID", "*Reserved for future use.*"
       "0b111", "DYN", "In instruction’s *rm* field, selects dynamic rounding mode;
        In Rounding Mode register, *Invalid*."

Floating-Point Control and Status Register (``fcsr``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x3
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The floating-point control and status register, ``fcsr``, is a RISC-V control and status register (CSR). It is a read/write register that selects the dynamic rounding mode for floating-point arithmetic operations and holds the accrued exception flags.

    The ``fcsr`` register can be read and written with the FRCSR and FSCSR instructions, which are assembler pseudoinstructions built on the underlying CSR access instructions. FRCSR reads ``fcsr`` by copying it into integer register *rd*. FSCSR swaps the value in ``fcsr`` by copying the original value into integer register *rd*, and then writing a new value obtained from integer register *rs1* into ``fcsr``.

    The fields within the ``fcsr`` can also be accessed individually through different CSR addresses, and separate assembler pseudoinstructions are defined for these accesses. The FRRM instruction reads the Rounding Mode field ``frm`` and copies it into the least-significant three bits of integer register *rd*, with zero in all other bits. FSRM swaps the value in frm by copying the original value into integer register *rd*, and then writing a new value obtained from the three least-significant bits of integer register *rs1* into ``frm``. FRFLAGS and FSFLAGS are defined analogously for the Accrued Exception Flags field ``fflags``.


.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:8]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[7:5]", "``FRM``", "Floating-Point Rounding Mode", "RW", "0b0"
   "[4]", "``NV``", "Invalid Operation", "RW", "0b0"
   "[3]", "``DZ``", "Divide by Zero", "RW", "0b0"
   "[2]", "``OF``", "Overflow", "RW", "0b0"
   "[1]", "``UF``", "Underflow", "RW", "0b0"
   "[0]", "``NX``", "Inexact", "RW", "0b0"

:Floating-Point Rounding Mode (``FRM``): Floating-point operations use either a static rounding mode encoded in the instruction, or a dynamic rounding mode held in ``frm``. Rounding modes are encoded as shown in the enumerated value. A value of 111 in
    the instruction’s *rm* field selects the dynamic rounding mode held in ``frm``. If ``frm`` is set to an invalid value (101–111), any subsequent attempt to execute a floating-point operation with a dynamic rounding mode will raise an illegal instruction exception. Some instructions, including widening conversions, have the *rm* field but are nevertheless unaffected by the rounding mode; software should set their *rm* field to RNE (000).

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b000", "RNE", "Round to Nearest, ties to Even"
       "0b001", "RTZ", "Round towards Zero"
       "0b010", "RDN", "Round Down"
       "0b011", "RUP", "Round Up"
       "0b100", "RMM", "Round to Nearest, ties to Max Magnitude"
       "0b101 - 0b110", "INVALID", "*Reserved for future use.*"
       "0b111", "DYN", "In instruction’s *rm* field, selects dynamic rounding mode;
        In Rounding Mode register, *Invalid*."
:Invalid Operation (``NV``): The accrued exception flags indicate the exception conditions that have arisen on any floating-point arithmetic instruction since the field was last reset by software. The base RISC-V ISA does not support generating a trap on the setting of a floating-point exception flag.

:Divide by Zero (``DZ``): The accrued exception flags indicate the exception conditions that have arisen on any floating-point arithmetic instruction since the field was last reset by software. The base RISC-V ISA does not support generating a trap on the setting of a floating-point exception flag.

:Overflow (``OF``): The accrued exception flags indicate the exception conditions that have arisen on any floating-point arithmetic instruction since the field was last reset by software. The base RISC-V ISA does not support generating a trap on the setting of a floating-point exception flag.

:Underflow (``UF``): The accrued exception flags indicate the exception conditions that have arisen on any floating-point arithmetic instruction since the field was last reset by software. The base RISC-V ISA does not support generating a trap on the setting of a floating-point exception flag.

:Inexact (``NX``): The accrued exception flags indicate the exception conditions that have arisen on any floating-point arithmetic instruction since the field was last reset by software. The base RISC-V ISA does not support generating a trap on the setting of a floating-point exception flag.


Supervisor Status (``sstatus``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x100
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The ``sstatus`` register keeps track of the processor’s current operating state.

    The ``sstatus`` register is a subset of the ``mstatus`` register.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31]", "``SD``", "State Dirty", "RO", "0b0"
   "[30:20]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[19]", "``MXR``", "Make eXecutable Readable", "RW", "0b0"
   "[18]", "``SUM``", "Supervisor User Memory", "RW", "0b0"
   "[17]", "``reserved_1``", "Reserved", "RO", "0b0"
   "[16:15]", "``XS``", "Extension State", "RO", "0b0"
   "[14:13]", "``FS``", "Floating-point unit State", "RW", "0b0"
   "[12:9]", "``reserved_2``", "Reserved", "RO", "0b0"
   "[8]", "``SPP``", "Supervisor mode Prior Privilege", "RW", "0b0"
   "[7:6]", "``reserved_3``", "Reserved", "RO", "0b0"
   "[5]", "``SPIE``", "Supervisor mode Prior Interrupt Enable", "RW", "0b0"
   "[4]", "``UPIE``", "", "RW", "0b0"
   "[3:2]", "``reserved_4``", "Reserved", "RO", "0b0"
   "[1]", "``SIE``", "Supervisor mode Interrupt Enable", "RW", "0b0"
   "[0]", "``UIE``", "", "RW", "0b0"

:State Dirty (``SD``): The SD bit is a read-only bit that summarizes whether either the FS, VS, or XS fields signal the presence of some dirty state that will require saving extended user context to memory. If FS, XS, and VS are all read-only zero, then SD is also always zero.

:Make eXecutable Readable (``MXR``): The MXR bit modifies the privilege with which loads access virtual memory. When MXR=0, only loads from pages marked readable will succeed. When MXR=1, loads from pages marked either readable or executable (R=1 or X=1) will succeed. MXR has no effect when page-based virtual memory is not in effect.

:Supervisor User Memory (``SUM``): The SUM (permit Supervisor User Memory access) bit modifies the privilege with which S-mode loads and stores access virtual memory. When SUM=0, S-mode memory accesses to pages that are accessible by U-mode will fault. When SUM=1, these accesses are permitted. SUM has no effect when page-based virtual memory is not in effect. Note that, while SUM is ordinarily ignored when not executing in S-mode, it *is* in effect when MPRV=1 and MPP=S. SUM is read-only 0 if S-mode is not supported or if ``satp``.MODE is read-only 0.

:Extension State (``XS``): The XS field is used to reduce the cost of context save and restore by setting and tracking the current state of the user-mode extensions. The XS field encodes the status of the additional user-mode extensions and associated state.

    This field can be checked by a context switch routine to quickly determine whether a state save or restore is required. If a save or restore is required, additional instructions and CSRs are typically required to effect and optimize the process.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b00", "Off", "All off"
       "0b01", "Initial", "None dirty or clean, some on"
       "0b10", "Clean", "None dirty, some clean"
       "0b11", "Dirty", "Some dirty"
:Floating-point unit State (``FS``): The FS field is used to reduce the cost of context save and restore by setting and tracking the current state of the floating-point unit. The FS field encodes the status of the floating-point unit state, including the floating-point registers ``f0–f31`` and the CSRs ``fcsr``, ``frm``, and ``fflags``.

    This field can be checked by a context switch routine to quickly determine whether a state save or restore is required. If a save or restore is required, additional instructions and CSRs are typically required to effect and optimize the process.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b00", "Off", ""
       "0b01", "Initial", ""
       "0b10", "Clean", ""
       "0b11", "Dirty", ""
:Supervisor mode Prior Privilege (``SPP``): SPP bit indicates the privilege level at which a hart was executing before entering supervisor mode. When a trap is taken, SPP is set to 0 if the trap originated from user mode, or 1 otherwise. When an SRET instruction is executed to return from the trap handler, the privilege level is set to user mode if the SPP bit is 0, or supervisor mode if the SPP bit is 1; SPP is then set to 0.

:Supervisor mode Prior Interrupt Enable (``SPIE``): The SPIE bit indicates whether supervisor interrupts were enabled prior to trapping into supervisor mode. When a trap is taken into supervisor mode, SPIE is set to SIE, and SIE is set to 0. When
    an SRET instruction is executed, SIE is set to SPIE, then SPIE is set to 1.

:``UPIE``: When a URET instruction is executed, UIE is set to UPIE, and UPIE is set to 1.

:Supervisor mode Interrupt Enable (``SIE``): The SIE bit enables or disables all interrupts in supervisor mode. When SIE is clear, interrupts are not taken while in supervisor mode. When the hart is running in user-mode, the value in SIE is ignored, and supervisor-level interrupts are enabled. The supervisor can disable individual interrupt sources using the ``sie`` CSR.

:``UIE``: The UIE bit enables or disables user-mode interrupts.


Supervisor Interrupt Enable (``sie``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x104
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The ``sie`` is the register containing supervisor interrupt enable bits.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:10]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[9]", "``SEIE``", "Supervisor-level External Interrupt Enable", "RW", "0b0"
   "[8]", "``UEIE``", "", "RW", "0b0"
   "[7:6]", "``reserved_1``", "Reserved", "RO", "0b0"
   "[5]", "``STIE``", "Supervisor-level Timer Interrupt Enable", "RW", "0b0"
   "[4]", "``UTIE``", "", "RW", "0b0"
   "[3:2]", "``reserved_2``", "Reserved", "RO", "0b0"
   "[1]", "``SSIE``", "Supervisor-level Software Interrupt Enable", "RW", "0b0"
   "[0]", "``USIE``", "", "RW", "0b0"

:Supervisor-level External Interrupt Enable (``SEIE``): SEIE is the interrupt-enable bit for supervisor-level external interrupts.

:``UEIE``: User-level external interrupts are disabled when the UEIE bit in the sie register is clear.

:Supervisor-level Timer Interrupt Enable (``STIE``): STIE is the interrupt-enable bit for supervisor-level timer interrupts.

:``UTIE``: User-level timer interrupts are disabled when the UTIE bit in the sie register is clear.

:Supervisor-level Software Interrupt Enable (``SSIE``): SSIE is the interrupt-enable bit for supervisor-level software interrupts.

:``USIE``: User-level software interrupts are disabled when the USIE bit in the sie register is clear


Supervisor Trap Vector Base Address (``stvec``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x105
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The ``stvec`` register holds trap vector configuration, consisting of a vector base address (BASE) and a vector mode (MODE).

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:2]", "``BASE``", "", "RW", "0b0"
   "[1:0]", "``MODE``", "", "RW", "0b0"

:``BASE``: The BASE field in stvec is a WARL field that can hold any valid virtual or physical address, subject to the following alignment constraints: the address must be 4-byte aligned, and MODE settings other than Direct might impose additional alignment constraints on the value in the BASE field.

:``MODE``: When MODE=Direct, all traps into supervisor mode cause the ``pc`` to be set to the address in the BASE field. When MODE=Vectored, all synchronous exceptions into supervisor mode cause the ``pc`` to be set to the address in the BASE field, whereas interrupts cause the ``pc`` to be set to the address in the BASE field plus four times the interrupt cause number.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b00", "Direct", "All exceptions set ``pc`` to BASE."
       "0b01", "Vectored", "Asynchronous interrupts set pc to BASE+4×cause."
       "0b10 - 0b11", "Reserved", "*Reserved*"

Supervisor Counter Enable (``scounteren``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x106
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The counter-enable register ``scounteren`` controls the availability of the hardware performance monitoring counters to U-mode.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:3]", "``HPMn``", "Hpmcountern", "RW", "0b0"
   "[2]", "``IR``", "Instret", "RW", "0b0"
   "[1]", "``TM``", "Time", "RW", "0b0"
   "[0]", "``CY``", "Cycle", "RW", "0b0"

:Hpmcountern (``HPMn``): When HPMn is clear, attempts to read the ``hpmcountern`` register while executing in U-mode will cause an illegal instruction exception. When this bit is set, access to the corresponding register is permitted.

:Instret (``IR``): When IR is clear, attempts to read the ``instret`` register while executing in U-mode will cause an illegal instruction exception. When this bit is set, access to the corresponding register is permitted.

:Time (``TM``): When TM is clear, attempts to read the ``time`` register while executing in U-mode will cause an illegal instruction exception. When this bit is set, access to the corresponding register is permitted.

:Cycle (``CY``): When CY is clear, attempts to read the ``cycle`` register while executing in U-mode will cause an illegal instruction exception. When this bit is set, access to the corresponding register is permitted.


Supervisor Scratch (``sscratch``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x140
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The ``sscratch`` register is dedicated for use by the supervisor.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``SSCRATCH``", "Supervisor Scratch", "RW", "0b0"

:Supervisor Scratch (``SSCRATCH``): Typically, ``sscratch`` is used to hold a pointer to the hart-local supervisor context while the hart is executing user code. At the beginning of a trap handler, ``sscratch`` is swapped with a user register to provide an initial working register.


Supervisor Exception Program Counter (``sepc``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x141
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: When a trap is taken into S-mode, ``sepc`` is written with the virtual address of the instruction that was interrupted or that encountered the exception. Otherwise, ``sepc`` is never written by the implementation, though it may be explicitly written by software.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``SEPC``", "Supervisor Exception Program Counter", "RW", "0b0"

:Supervisor Exception Program Counter (``SEPC``): The low bit of SEPC (SEPC[0]) is always zero. On implementations that support only IALIGN=32, the two low bits (SEPC[1:0]) are always zero.


Supervisor Cause (``scause``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x142
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: When a trap is taken into S-mode, ``scause`` is written with a code indicating the event that caused the trap. Otherwise, ``scause`` is never written by the implementation, though it may be explicitly written by software.

    Supervisor cause register (``scause``) values after trap are shown in the following table.

    =========  ==============  ==============================
    Interrupt  Exception Code  Description
    =========  ==============  ==============================
            1               0  *Reserved*
            1               1  Supervisor software interrupt
            1             2-4  *Reserved*
            1               5  Supervisor timer interrupt
            1             6-8  *Reserved*
            1               9  Supervisor external interrupt
            1           10-15  *Reserved*
            1             ≥16  *Designated for platform use*
            0               0  Instruction address misaligned
            0               1  Instruction access fault
            0               2  Illegal instruction
            0               3  Breakpoint
            0               4  Load address misaligned
            0               5  Load access fault
            0               6  Store/AMO address misaligned
            0               7  Store/AMO access fault
            0               8  Environment call from U-mode
            0               9  Environment call from S-mode
            0           10-11  *Reserved*
            0              12  Instruction page fault
            0              13  Load page fault
            0              14  *Reserved*
            0              15  Store/AMO page fault
            0           16-23  *Reserved*
            0           24-31  *Designated for custom use*
            0           32-47  *Reserved*
            0           48-63  *Designated for custom use*
            0             ≥64  *Reserved*
    =========  ==============  ==============================


.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31]", "``Interrupt``", "", "RW", "0b0"
   "[30:0]", "``Exception_Code``", "Exception Code", "RW", "0b0"

:``Interrupt``: The Interrupt bit in the ``scause`` register is set if the trap was caused by an interrupt.

:Exception Code (``Exception_Code``): The Exception Code field contains a code identifying the last exception or interrupt.


Supervisor Trap Value (``stval``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x143
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: When a trap is taken into S-mode, ``stval`` is written with exception-specific information to assist software in handling the trap. Otherwise, ``stval`` is never written by the implementation, though it may be explicitly written by software. The hardware platform will specify which exceptions must set ``stval`` informatively and which may unconditionally set it to zero.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``STVAL``", "Supervisor Trap Value", "RW", "0b0"

:Supervisor Trap Value (``STVAL``): If ``stval`` is written with a nonzero value when a breakpoint, address-misaligned, access-fault, or page-fault exception occurs on an instruction fetch, load, or store, then ``stval`` will contain the faulting virtual address.

    If ``stval`` is written with a nonzero value when a misaligned load or store causes an access-fault or page-fault exception, then ``stval`` will contain the virtual address of the portion of the access that caused the fault.

    If ``stval`` is written with a nonzero value when an instruction access-fault or page-fault exception occurs on a system with variable-length instructions, then ``stval`` will contain the virtual address of the portion of the instruction that caused the fault, while ``sepc`` will point to the beginning of the instruction.

    The ``stval`` register can optionally also be used to return the faulting instruction bits on an illegal instruction exception (``sepc`` points to the faulting instruction in memory). If ``stval`` is written with a nonzero value when an illegal-instruction exception occurs, then ``stval`` will contain the shortest of:

    * the actual faulting instruction
    * the first ILEN bits of the faulting instruction
    * the first SXLEN bits of the faulting instruction

    The value loaded into ``stval`` on an illegal-instruction exception is right-justified and all unused upper bits are cleared to zero. For other traps, ``stval`` is set to zero, but a future standard may redefine ``stval’s`` setting for other traps.


Supervisor Interrupt Pending (``sip``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x144
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The ``sip`` register contains information on pending interrupts.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:10]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[9]", "``SEIP``", "Supervisor-level External Interrupt Pending", "RO", "0b0"
   "[8]", "``UEIP``", "", "RW", "0b0"
   "[7:6]", "``reserved_1``", "Reserved", "RO", "0b0"
   "[5]", "``STIP``", "Supervisor-level Timer Interrupt Pending", "RO", "0b0"
   "[4]", "``UTIP``", "", "RW", "0b0"
   "[3:2]", "``reserved_2``", "Reserved", "RO", "0b0"
   "[1]", "``SSIP``", "Supervisor-level Software Interrupt Pending", "RO", "0b0"
   "[0]", "``USIP``", "", "RW", "0b0"

:Supervisor-level External Interrupt Pending (``SEIP``): SEIP is the interrupt-pending bit for supervisor-level external interrupts.

:``UEIP``: UEIP may be written by S-mode software to indicate to U-mode that an external interrupt is pending.

:Supervisor-level Timer Interrupt Pending (``STIP``): SEIP is the interrupt-pending bit for supervisor-level timer interrupts.

:``UTIP``: A user-level timer interrupt is pending if the UTIP bit in the sip register is set

:Supervisor-level Software Interrupt Pending (``SSIP``): SSIP is the interrupt-pending bit for supervisor-level software interrupts.

:``USIP``: A user-level software interrupt is triggered on the current hart by writing 1 to its user software interrupt-pending (USIP) bit


Supervisor Address Translation and Protection (``satp``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x180
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The ``satp`` register controls supervisor-mode address translation and protection.

    The ``satp`` register is considered active when the effective privilege mode is S-mode or U-mode. Executions of the address-translation algorithm may only begin using a given value of ``satp`` when ``satp`` is active.

    .. note::
      Writing ``satp`` does not imply any ordering constraints between page-table updates and subsequent address translations, nor does it imply any invalidation of address-translation caches. If the new address space’s page tables have been modified, or if an ASID is reused, it may be necessary to execute an SFENCE.VMA instruction after, or in some cases before, writing ``satp``.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31]", "``MODE``", "Mode", "RW", "0b0"
   "[30:22]", "``ASID``", "Address Space Identifier", "RW", "0b0"
   "[21:0]", "``PPN``", "Physical Page Number", "RW", "0b0"

:Mode (``MODE``): This bitfield selects the current address-translation scheme.

    When MODE=Bare, supervisor virtual addresses are equal to supervisor physical addresses, and there is no additional memory protection beyond the physical memory protection scheme.

    To select MODE=Bare, software must write zero to the remaining fields of ``satp`` (bits 30–0). Attempting to select MODE=Bare with a nonzero pattern in the remaining fields has an ``unspecified`` effect on the value that the remaining fields assume and an ``unspecified`` effect on address translation and protection behavior.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0", "Bare", "No translation or protection."
       "1", "Sv32", "Page-based 32-bit virtual addressing."
:Address Space Identifier (``ASID``): This bitfield facilitates address-translation fences on a per-address-space basis.

:Physical Page Number (``PPN``): This bitfield holds the root page table, i.e., its supervisor physical address divided by 4 KiB.


Machine Status (``mstatus``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x300
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The ``mstatus`` register keeps track of and controls the hart’s current operating state.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31]", "``SD``", "State Dirty", "RO", "0b0"
   "[30:23]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[22]", "``TSR``", "Trap SRET", "RW", "0b0"
   "[21]", "``TW``", "Timeout Wait", "RW", "0b0"
   "[20]", "``TVM``", "Trap Virtual Memory", "RW", "0b0"
   "[19]", "``MXR``", "Make eXecutable Readable", "RW", "0b0"
   "[18]", "``SUM``", "Supervisor User Memory", "RW", "0b0"
   "[17]", "``MPRV``", "Modify Privilege", "RW", "0b0"
   "[16:15]", "``XS``", "Extension State", "RO", "0b0"
   "[14:13]", "``FS``", "Floating-point unit State", "RW", "0b0"
   "[12:11]", "``MPP``", "Machine mode Prior Privilege", "RW", "0b0"
   "[10:9]", "``reserved_1``", "Reserved", "RO", "0b0"
   "[8]", "``SPP``", "Supervisor mode Prior Privilege", "RW", "0b0"
   "[7]", "``MPIE``", "Machine mode Prior Interrupt Enable", "RW", "0b0"
   "[6]", "``reserved_2``", "Reserved", "RO", "0b0"
   "[5]", "``SPIE``", "Supervisor mode Prior Interrupt Enable", "RW", "0b0"
   "[4]", "``UPIE``", "", "RW", "0b0"
   "[3]", "``MIE``", "Machine mode Interrupt Enable", "RW", "0b0"
   "[2]", "``reserved_3``", "Reserved", "RO", "0b0"
   "[1]", "``SIE``", "Supervisor mode Interrupt Enable", "RW", "0b0"
   "[0]", "``UIE``", "", "RW", "0b0"

:State Dirty (``SD``): The SD bit is a read-only bit that summarizes whether either the FS, VS, or XS fields signal the presence of some dirty state that will require saving extended user context to memory. If FS, XS, and VS are all read-only zero, then SD is also always zero.

:Trap SRET (``TSR``): The TSR bit supports intercepting the supervisor exception return instruction, SRET. When TSR=1, attempts to execute SRET while executing in S-mode will raise an illegal instruction exception. When TSR=0, this operation is permitted in S-mode.

:Timeout Wait (``TW``): The TW bit supports intercepting the WFI instruction. When TW=0, the WFI instruction may execute in lower privilege modes when not prevented for some other reason. When TW=1, then if WFI is executed in any less-privileged mode, and it does not complete within an implementation-specific, bounded time limit, the WFI instruction causes an illegal instruction exception. The time limit may always be 0, in which case WFI always causes an illegal instruction exception in less-privileged modes when TW=1.

:Trap Virtual Memory (``TVM``): The TVM bit supports intercepting supervisor virtual-memory management operations. When TVM=1, attempts to read or write the ``satp`` CSR or execute an SFENCE.VMA or SINVAL.VMA instruction while executing in S-mode will raise an illegal instruction exception. When TVM=0, these operations are permitted in S-mode.

:Make eXecutable Readable (``MXR``): The MXR bit modifies the privilege with which loads access virtual memory. When MXR=0, only loads from pages marked readable will succeed. When MXR=1, loads from pages marked either readable or executable (R=1 or X=1) will succeed. MXR has no effect when page-based virtual memory is not in effect.

:Supervisor User Memory (``SUM``): The SUM (permit Supervisor User Memory access) bit modifies the privilege with which S-mode loads and stores access virtual memory. When SUM=0, S-mode memory accesses to pages that are accessible by U-mode will fault. When SUM=1, these accesses are permitted. SUM has no effect when page-based virtual memory is not in effect. Note that, while SUM is ordinarily ignored when not executing in S-mode, it is in effect when MPRV=1 and MPP=S.

:Modify Privilege (``MPRV``): The MPRV (Modify PRiVilege) bit modifies the effective privilege mode, i.e., the privilege level at which loads and stores execute. When MPRV=0, loads and stores behave as normal, using the translation and protection mechanisms of the current privilege mode. When MPRV=1, load and store memory addresses are translated and protected, and endianness is applied, as though the current privilege mode were set to MPP. Instruction address-translation and protection are unaffected by the setting of MPRV.

:Extension State (``XS``): The XS field is used to reduce the cost of context save and restore by setting and tracking the current state of the user-mode extensions. The XS field encodes the status of the additional user-mode extensions and associated state.

    This field can be checked by a context switch routine to quickly determine whether a state save or restore is required. If a save or restore is required, additional instructions and CSRs are typically required to effect and optimize the process.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b00", "Off", "All off"
       "0b01", "Initial", "None dirty or clean, some on"
       "0b10", "Clean", "None dirty, some clean"
       "0b11", "Dirty", "Some dirty"
:Floating-point unit State (``FS``): The FS field is used to reduce the cost of context save and restore by setting and tracking the current state of the floating-point unit. The FS field encodes the status of the floating-point unit state, including the floating-point registers ``f0–f31`` and the CSRs ``fcsr``, ``frm``, and ``fflags``.

    This field can be checked by a context switch routine to quickly determine whether a state save or restore is required. If a save or restore is required, additional instructions and CSRs are typically required to effect and optimize the process.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b00", "Off", ""
       "0b01", "Initial", ""
       "0b10", "Clean", ""
       "0b11", "Dirty", ""
:Machine mode Prior Privilege (``MPP``): Holds the previous privilege mode for machine mode.

:Supervisor mode Prior Privilege (``SPP``): Holds the previous privilege mode for supervisor mode.

:Machine mode Prior Interrupt Enable (``MPIE``): Indicates whether machine interrupts were enabled prior to trapping into machine mode.

:Supervisor mode Prior Interrupt Enable (``SPIE``): Indicates whether supervisor interrupts were enabled prior to trapping into supervisor mode.

:``UPIE``: indicates whether user-level interrupts were enabled prior to taking a user-level trap

:Machine mode Interrupt Enable (``MIE``): Global interrupt-enable bit for Machine mode.

:Supervisor mode Interrupt Enable (``SIE``): Global interrupt-enable bit for Supervisor mode.

:``UIE``: Global interrupt-enable bits


Machine ISA (``misa``)
~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x301
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: The misa CSR is reporting the ISA supported by the hart.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:30]", "``MXL``", "Machine XLEN", "RW", "0b0"
   "[29:26]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[25:0]", "``Extensions``", "Extensions", "RW", "0b0"

:Machine XLEN (``MXL``): The MXL field encodes the native base integer ISA width.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b01", "XLEN_32", ""
       "0b10", "XLEN_64", ""
       "0b11", "XLEN_128", ""
:Extensions (``Extensions``): The Extensions field encodes the presence of the standard extensions, with a single bit per letter of the alphabet.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b00000000000000000000000001", "A", "Atomic extension."
       "0b00000000000000000000000010", "B", "*Tentatively reserved for Bit-Manipulation extension.*"
       "0b00000000000000000000000100", "C", "Compressed extension."
       "0b00000000000000000000001000", "D", "Double-precision floating-point extension."
       "0b00000000000000000000010000", "E", "RV32E base ISA."
       "0b00000000000000000000100000", "F", "Single-precision floating-point extension."
       "0b00000000000000000001000000", "G", "*Reserved.*"
       "0b00000000000000000010000000", "H", "Hypervisor extension."
       "0b00000000000000000100000000", "I", "RV32I/64I/128I base ISA."
       "0b00000000000000001000000000", "J", "*Tentatively reserved for Dynamically Translated Languages extension.*"
       "0b00000000000000010000000000", "K", "*Reserved.*"
       "0b00000000000000100000000000", "L", "*Reserved.*"
       "0b00000000000001000000000000", "M", "Integer Multiply/Divide extension."
       "0b00000000000010000000000000", "N", "*Tentatively reserved for User-Level Interrupts extension.*"
       "0b00000000000100000000000000", "O", "*Reserved.*"
       "0b00000000001000000000000000", "P", "*Tentatively reserved for Packed-SIMD extension.*"
       "0b00000000010000000000000000", "Q", "Quad-precision floating-point extension."
       "0b00000000100000000000000000", "R", "*Reserved.*"
       "0b00000001000000000000000000", "S", "Supervisor mode implemented."
       "0b00000010000000000000000000", "T", "*Reserved.*"
       "0b00000100000000000000000000", "U", "User mode implemented."
       "0b00001000000000000000000000", "V", "*Tentatively reserved for Vector extension.*"
       "0b00010000000000000000000000", "W", "*Reserved.*"
       "0b00100000000000000000000000", "X", "Non-standard extensions present."
       "0b01000000000000000000000000", "Y", "*Reserved.*"
       "0b10000000000000000000000000", "Z", "*Reserved.*"

Machine Exception Delegation (``medeleg``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x302
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Provides individual read/write bits to indicate that certain exceptions should be processed directly by a lower privilege level.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``Synchronous_Exceptions``", "Synchronous Exceptions", "RW", "0b0"

:Synchronous Exceptions (``Synchronous_Exceptions``): There is a bit position allocated for every synchronous exception,
    with the index of the bit position equal to the value returned in the ``mcause`` register.


Machine Interrupt Delegation (``mideleg``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x303
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Provides individual read/write bits to indicate that certain interrupts should be processed directly by a lower privilege level.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``Interrupts``", "Interrupts", "RW", "0b0"

:Interrupts (``Interrupts``): This bitfield holds trap delegation bits for individual interrupts, with the layout of bits matching those in the ``mip`` register.


Machine Interrupt Enable (``mie``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x304
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: This register contains machine interrupt enable bits.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:12]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[11]", "``MEIE``", "M-mode External Interrupt Enable", "RW", "0b0"
   "[10]", "``reserved_1``", "Reserved", "RO", "0b0"
   "[9]", "``SEIE``", "S-mode External Interrupt Enable", "RW", "0b0"
   "[8]", "``UEIE``", "", "RW", "0b0"
   "[7]", "``MTIE``", "M-mode Timer Interrupt Enable", "RW", "0b0"
   "[6]", "``reserved_2``", "Reserved", "RO", "0b0"
   "[5]", "``STIE``", "S-mode Timer Interrupt Enable", "RW", "0b0"
   "[4]", "``UTIE``", "", "RW", "0b0"
   "[3]", "``MSIE``", "M-mode Software Interrupt Enable", "RW", "0b0"
   "[2]", "``reserved_3``", "Reserved", "RO", "0b0"
   "[1]", "``SSIE``", "S-mode Software Interrupt Enable", "RW", "0b0"
   "[0]", "``USIE``", "", "RW", "0b0"

:M-mode External Interrupt Enable (``MEIE``): Enables machine mode external interrupts.

:S-mode External Interrupt Enable (``SEIE``): Enables supervisor mode external interrupts.

:``UEIE``: enables U-mode external interrupts

:M-mode Timer Interrupt Enable (``MTIE``): Enables machine mode timer interrupts.

:S-mode Timer Interrupt Enable (``STIE``): Enables supervisor mode timer interrupts.

:``UTIE``: timer interrupt-enable bit for U-mode

:M-mode Software Interrupt Enable (``MSIE``): Enables machine mode software interrupts.

:S-mode Software Interrupt Enable (``SSIE``): Enables supervisor mode software interrupts.

:``USIE``: enable U-mode software interrupts


Machine Trap Vector (``mtvec``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x305
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: This register holds trap vector configuration, consisting of a vector base address and a vector mode.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:2]", "``BASE``", "", "RW", "0b0"
   "[1:0]", "``MODE``", "", "RW", "0b0"

:``BASE``: Holds the vector base address. The value in the BASE field must always be aligned on a 4-byte boundary.

:``MODE``: Imposes additional alignment constraints on the value in the BASE field.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b00", "Direct", "All exceptions set ``pc`` to BASE."
       "0b01", "Vectored", "Asynchronous interrupts set ``pc`` to BASE+4×cause."
       "0b10-0b11", "Reserved", "*Reserved.*"

Machine Counter Enable (``mcountern``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x306
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: This register controls the availability of the hardware performance-monitoring counters to the next-lowest privileged mode.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:3]", "``HPMn``", "Hpmcountern", "RW", "0b0"
   "[2]", "``IR``", "Instret", "RW", "0b0"
   "[1]", "``TM``", "Time", "RW", "0b0"
   "[0]", "``CY``", "Cycle", "RW", "0b0"

:Hpmcountern (``HPMn``): When HPMn is clear, attempts to read the ``hpmcountern`` register while executing in S-mode or U-mode will cause an illegal instruction exception. When this bit is set, access to the corresponding register is permitted in the next implemented privilege mode.

:Instret (``IR``): When IR is clear, attempts to read the ``instret`` register while executing in S-mode or U-mode will cause an illegal instruction exception. When this bit is set, access to the corresponding register is permitted in the next implemented privilege mode.

:Time (``TM``): When TM is clear, attempts to read the ``time`` register while executing in S-mode or U-mode will cause an illegal instruction exception. When this bit is set, access to the corresponding register is permitted in the next implemented privilege mode.

:Cycle (``CY``): When CY is clear, attempts to read the ``cycle`` register while executing in S-mode or U-mode will cause an illegal instruction exception. When this bit is set, access to the corresponding register is permitted in the next implemented privilege mode.


Hardware Performance-Monitoring Event Selector (``hpmevent[6]``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x323 [+ i*0x1]
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: This register controls which event causes the corresponding counter to increment.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:5]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[4:0]", "``mhpmevent``", "", "RW", "0b0"

:``mhpmevent``: event selector CSRs


Machine Scratch (``mscratch``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x340
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: This register is used to hold a pointer to a machine-mode hart-local context space and swapped with a user register upon entry to an M-mode trap handler.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``mscratch``", "Machine Scratch", "RW", "0b0"

:Machine Scratch (``mscratch``): Holds a pointer to a machine-mode hart-local context space and swapped with a user register upon entry to an M-mode trap handler.


Machine Exception Program Counter (``mepc``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x341
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: This register must be able to hold all valid virtual addresses.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``mepc``", "Machine Exception Program Counter", "RW", "0b0"

:Machine Exception Program Counter (``mepc``): When a trap is taken into M-mode, ``mepc`` is written with the virtual address of the instruction that was interrupted or that encountered the exception.


Machine Cause (``mcause``)
~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x342
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: When a trap is taken into M-mode, mcause is written with a code indicating the event that caused the trap.

    Machine cause register (``mcause``) values after trap are shown in the following table.

    =========  ==============  ==============================
    Interrupt  Exception Code  Description
    =========  ==============  ==============================
            1               0  *Reserved*
            1               1  Supervisor software interrupt
            1             2-4  *Reserved*
            1               5  Supervisor timer interrupt
            1             6-8  *Reserved*
            1               9  Supervisor external interrupt
            1           10-15  *Reserved*
            1             ≥16  *Designated for platform use*
            0               0  Instruction address misaligned
            0               1  Instruction access fault
            0               2  Illegal instruction
            0               3  Breakpoint
            0               4  Load address misaligned
            0               5  Load access fault
            0               6  Store/AMO address misaligned
            0               7  Store/AMO access fault
            0               8  Environment call from U-mode
            0               9  Environment call from S-mode
            0           10-11  *Reserved*
            0              12  Instruction page fault
            0              13  Load page fault
            0              14  *Reserved*
            0              15  Store/AMO page fault
            0           16-23  *Reserved*
            0           24-31  *Designated for custom use*
            0           32-47  *Reserved*
            0           48-63  *Designated for custom use*
            0             ≥64  *Reserved*
    =========  ==============  ==============================

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31]", "``Interrupt``", "Interrupt", "RW", "0b0"
   "[30:0]", "``exception_code``", "Exception Code", "RW", "0b0"

:Interrupt (``Interrupt``): This bit is set if the trap was caused by an interrupt.

:Exception Code (``exception_code``): This field contains a code identifying the last exception or interrupt.


Machine Trap Value (``mtval``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x343
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: When a trap is taken into M-mode, mtval is either set to zero or written with exception-specific information to assist software in handling the trap.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``mtval``", "Machine Trap Value", "RW", "0b0"

:Machine Trap Value (``mtval``): If ``mtval`` is written with a nonzero value when a breakpoint, address-misaligned, access-fault, or page-fault exception occurs on an instruction fetch, load, or store, then mtval will contain the faulting virtual address.

    If ``mtval`` is written with a nonzero value when a misaligned load or store causes an access-fault or page-fault exception, then ``mtval`` will contain the virtual address of the portion of the access that caused the fault.

    If ``mtval`` is written with a nonzero value when an instruction access-fault or page-fault exception occurs on a system with variable-length instructions, then ``mtval`` will contain the virtual address of the portion of the instruction that caused the fault, while ``mepc`` will point to the beginning of the instruction.


Machine Interrupt Pending (``mip``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x344
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: This register contains machine interrupt pending bits.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:12]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[11]", "``MEIP``", "M-mode External Interrupt Pending", "RO", "0b0"
   "[10]", "``reserved_1``", "Reserved", "RO", "0b0"
   "[9]", "``SEIP``", "S-mode External Interrupt Pending", "RW", "0b0"
   "[8]", "``UEIP``", "", "RW", "0b0"
   "[7]", "``MTIP``", "M-mode Timer Interrupt Pending", "RO", "0b0"
   "[6]", "``reserved_2``", "Reserved", "RO", "0b0"
   "[5]", "``STIP``", "S-mode Timer Interrupt Pending", "RW", "0b0"
   "[4]", "``UTIP``", "", "RW", "0b0"
   "[3]", "``MSIP``", "M-mode Software Interrupt Pending", "RO", "0b0"
   "[2]", "``reserved_3``", "Reserved", "RO", "0b0"
   "[1]", "``SSIP``", "S-mode Software Interrupt Pending", "RW", "0b0"
   "[0]", "``USIP``", "", "RW", "0b0"

:M-mode External Interrupt Pending (``MEIP``): The interrupt-pending bit for machine-level external interrupts.

:S-mode External Interrupt Pending (``SEIP``): The interrupt-pending bit for supervisor-level external interrupts.

:``UEIP``: enables external interrupts

:M-mode Timer Interrupt Pending (``MTIP``): The interrupt-pending bit for machine-level timer interrupts.

:S-mode Timer Interrupt Pending (``STIP``): The interrupt-pending bit for supervisor-level timer interrupts.

:``UTIP``: Correspond to timer interrupt-pending bits for user interrupt

:M-mode Software Interrupt Pending (``MSIP``): The interrupt-pending bit for machine-level software interrupts.

:S-mode Software Interrupt Pending (``SSIP``): The interrupt-pending bit for supervisor-level software interrupts.

:``USIP``: A hart to directly write its own USIP bits when running in the appropriate mode


Physical Memory Protection Config 0 (``pmpcfg0``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x3A0
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Holds configuration 0-3.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:24]", "``pmp3cfg``", "Physical Memory Protection 3 Config", "RW", "0b0"
   "[23:16]", "``pmp2cfg``", "Physical Memory Protection 2 Config", "RW", "0b0"
   "[15:8]", "``pmp1cfg``", "Physical Memory Protection 1 Config", "RW", "0b0"
   "[7:0]", "``pmp0cfg``", "Physical Memory Protection 0 Config", "RW", "0b0"

:Physical Memory Protection 3 Config (``pmp3cfg``): Holds the configuration.

:Physical Memory Protection 2 Config (``pmp2cfg``): Holds the configuration.

:Physical Memory Protection 1 Config (``pmp1cfg``): Holds the configuration.

:Physical Memory Protection 0 Config (``pmp0cfg``): Holds the configuration.


Physical Memory Protection Config 1 (``pmpcfg1``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x3A1
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Holds configuration 4-7.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:24]", "``pmp7cfg``", "Physical Memory Protection 7 Config", "RW", "0b0"
   "[23:16]", "``pmp6cfg``", "Physical Memory Protection 6 Config", "RW", "0b0"
   "[15:8]", "``pmp5cfg``", "Physical Memory Protection 5 Config", "RW", "0b0"
   "[7:0]", "``pmp4cfg``", "Physical Memory Protection 4 Config", "RW", "0b0"

:Physical Memory Protection 7 Config (``pmp7cfg``): Holds the configuration.

:Physical Memory Protection 6 Config (``pmp6cfg``): Holds the configuration.

:Physical Memory Protection 5 Config (``pmp5cfg``): Holds the configuration.

:Physical Memory Protection 4 Config (``pmp4cfg``): Holds the configuration.


Physical Memory Protection Config 2 (``pmpcfg2``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x3A2
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Holds configuration 8-11.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:24]", "``pmp11cfg``", "Physical Memory Protection 11 Config", "RW", "0b0"
   "[23:16]", "``pmp10cfg``", "Physical Memory Protection 10 Config", "RW", "0b0"
   "[15:8]", "``pmp9cfg``", "Physical Memory Protection 9 Config", "RW", "0b0"
   "[7:0]", "``pmp8cfg``", "Physical Memory Protection 8 Config", "RW", "0b0"

:Physical Memory Protection 11 Config (``pmp11cfg``): Holds the configuration.

:Physical Memory Protection 10 Config (``pmp10cfg``): Holds the configuration.

:Physical Memory Protection 9 Config (``pmp9cfg``): Holds the configuration.

:Physical Memory Protection 8 Config (``pmp8cfg``): Holds the configuration.


Physical Memory Protection Config 3 (``pmpcfg3``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x3A3
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Holds configuration 12-15.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:24]", "``pmp15cfg``", "Physical Memory Protection 15 Config", "RW", "0b0"
   "[23:16]", "``pmp14cfg``", "Physical Memory Protection 14 Config", "RW", "0b0"
   "[15:8]", "``pmp13cfg``", "Physical Memory Protection 13 Config", "RW", "0b0"
   "[7:0]", "``pmp12cfg``", "Physical Memory Protection 12 Config", "RW", "0b0"

:Physical Memory Protection 15 Config (``pmp15cfg``): Holds the configuration.

:Physical Memory Protection 14 Config (``pmp14cfg``): Holds the configuration.

:Physical Memory Protection 13 Config (``pmp13cfg``): Holds the configuration.

:Physical Memory Protection 12 Config (``pmp12cfg``): Holds the configuration.


Physical Memory Protection Address (``pmpaddr[16]``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x3B0 [+ i*0x1]
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Address register for Physical Memory Protection.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``address``", "Address", "RW", "0b0"

:Address (``address``): Encodes bits 33-2 of a 34-bit physical address.


Instruction Cache (``icache``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x700
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000001
:Description: Custom Register to enable/disable for Icache [bit 0]

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:1]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[0]", "``icache``", "Instruction Cache", "RW", "0b1"

:Instruction Cache (``icache``): Custom Register


Data Cache (``dcache``)
~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x701
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000001
:Description: Custom Register to enable/disable for Dcache [bit 0]

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:1]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[0]", "``dcache``", "Data Cache", "RW", "0b1"

:Data Cache (``dcache``): Custom Register


Trigger Select (``tselect``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x7A0
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: This register determines which trigger is accessible through the other trigger registers.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``index``", "Index", "RW", "0b0"

:Index (``index``): The set of accessible triggers must start at 0, and be contiguous.

    Writes of values greater than or equal to the number of supported triggers may result in a different value in this register than what was written. To verify that what they wrote is a valid index, debuggers can read back the value and check that ``tselect`` holds what they wrote.

    Since triggers can be used both by Debug Mode and M-mode, the debugger must restore this register if it modifies it.


Trigger Data 1 (``tdata1``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x7A1
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Trigger-specific data.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:28]", "``type``", "Type", "RW", "0b0"
   "[27]", "``dmode``", "Debug Mode", "RW", "0b0"
   "[26:0]", "``data``", "Data", "RW", "0b0"

:Type (``type``): Type of trigger.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b0000", "no_trigger", "There is no trigger at this ``tselect``."
       "0b0001", "legacy_address_match_trigger", "The trigger is a legacy SiFive address match trigger. These should not be implemented and aren’t further documented here."
       "0b0010", "address_data_match_trigger", "The trigger is an address/data match trigger. The remaining bits in this register act as described in ``mcontrol``."
       "0b0011", "instruction_count_trigger", "The trigger is an instruction count trigger. The remaining bits in this register act as described in ``icount``."
       "0b0100", "interrupt_trigger", "The trigger is an interrupt trigger. The remaining bits in this register act as described in ``itrigger``."
       "0b0101", "exception_trigger", "The trigger is an exception trigger. The remaining bits in this register act as described in ``etrigger``."
       "0b0110-0b1110", "Reserved", "*Reserved.*"
       "0b1111", "trigger_exists", "This trigger exists (so enumeration shouldn’t terminate), but is not currently available."
:Debug Mode (``dmode``): This bit is only writable from Debug Mode.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0", "D_and_M_mode", "Both Debug and M-mode can write the ``tdata`` registers at the selected ``tselect``."
       "1", "M_mode_only", "Only Debug Mode can write the ``tdata`` registers at the selected ``tselect``. Writes from other modes are ignored."
:Data (``data``): Trigger-specific data.


Trigger Data 2 (``tdata2``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x7A2
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Trigger-specific data.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``data``", "Data", "RW", "0b0"

:Data (``data``): Trigger-specific data.


Trigger Data 3 (``tdata3``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x7A3
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Trigger-specific data.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``data``", "Data", "RW", "0b0"

:Data (``data``): Trigger-specific data.


Trigger Info (``tinfo``)
~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x7A4
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Shows trigger information.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:16]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[15:0]", "``info``", "Info", "RO", "0b0"

:Info (``info``): One bit for each possible ``type`` enumerated in ``tdata1``. Bit N corresponds to type N. If the bit is set, then that type is supported by the currently selected trigger.

    If the currently selected trigger doesn’t exist, this field contains 1.

    If ``type`` is not writable, this register may be unimplemented, in which case reading it causes an illegal instruction exception. In this case the debugger can read the only supported type from ``tdata1``.


Debug Control and Status (``dcsr``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x7B0
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Debug control and status register.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:28]", "``xdebugver``", "Debug Version", "RO", "0b0"
   "[27:16]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[15]", "``ebreakm``", "Environment Breakpoint M-mode", "RW", "0b0"
   "[14]", "``reserved_1``", "Reserved", "RO", "0b0"
   "[13]", "``ebreaks``", "Environment Breakpoint S-mode", "RW", "0b0"
   "[12]", "``ebreaku``", "Environment Breakpoint U-mode", "RW", "0b0"
   "[11]", "``stepie``", "Stepping Interrupt Enable", "RW", "0b0"
   "[10]", "``stopcount``", "Stop Counters", "RW", "0b0"
   "[9]", "``stoptime``", "Stop Timers", "RW", "0b0"
   "[8:6]", "``cause``", "Cause", "RW", "0b0"
   "[5]", "``reserved_2``", "Reserved", "RO", "0b0"
   "[4]", "``mprven``", "Modify Privilege Enable", "RW", "0b0"
   "[3]", "``nmip``", "Non-Maskable Interrupt Pending", "RO", "0b0"
   "[2]", "``step``", "Step", "RW", "0b0"
   "[1:0]", "``prv``", "Privilege level", "RW", "0b0"

:Debug Version (``xdebugver``): Shows the version of the debug support.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b0000", "no_ext_debug", "There is no external debug support."
       "0b0100", "ext_debug_spec", "External debug support exists as it is described in the riscv-debug-release document."
       "0b1111", "ext_debug_no_spec", "There is external debug support, but it does not conform to any available version of the riscv-debug-release spec."
:Environment Breakpoint M-mode (``ebreakm``): Shows the behavior of the ``ebreak`` instruction in machine mode.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0", "break_as_spec", "``ebreak`` instructions in M-mode behave as described in the Privileged Spec."
       "1", "break_to_debug", "``ebreak`` instructions in M-mode enter Debug Mode."
:Environment Breakpoint S-mode (``ebreaks``): Shows the behavior of the ``ebreak`` instruction in supervisor mode.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0", "break_as_spec", "``ebreak`` instructions in S-mode behave as described in the Privileged Spec."
       "1", "break_to_debug", "``ebreak`` instructions in S-mode enter Debug Mode."
:Environment Breakpoint U-mode (``ebreaku``): Shows the behvior of the ``ebreak`` instruction in user mode.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0", "break_as_spec", "``ebreak`` instructions in U-mode behave as described in the Privileged Spec."
       "1", "break_to_debug", "``ebreak`` instructions in U-mode enter Debug Mode."
:Stepping Interrupt Enable (``stepie``): Enables/disables interrupts for single stepping.

    The debugger must not change the value of this bit while the hart is running.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0", "disabled", "Interrupts are disabled during single stepping."
       "1", "enabled", "Interrupts are enabled during single stepping."
:Stop Counters (``stopcount``): Starts/stops incrementing counters in debug mode.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0", "increment_counters", "Increment counters as usual."
       "1", "dont_increment_counters", "Don’t increment any counters while in Debug Mode or on ``ebreak`` instructions that cause entry into Debug Mode."
:Stop Timers (``stoptime``): Starts/stops incrementing timers in debug mode.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0", "increment_timers", "Increment timers as usual."
       "1", "dont_increment_timers", "Don’t increment any hart-local timers while in Debug Mode."
:Cause (``cause``): Explains why Debug Mode was entered.

    When there are multiple reasons to enter Debug Mode in a single cycle, hardware sets ``cause`` to the cause with the highest priority.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b001", "ebreak_instruction", "An ``ebreak`` instruction was executed. (priority 3)"
       "0b010", "trigger_module", "The Trigger Module caused a breakpoint exception. (priority 4, highest)"
       "0b011", "debugger_request", "The debugger requested entry to Debug Mode using ``haltreq``. (priority 1)"
       "0b100", "single_step", "The hart single stepped because ``step`` was set. (priority 0, lowest)"
       "0b101", "reset_halt", "The hart halted directly out of reset due to ``resethaltreq``. It is also acceptable to report 3 when this happens. (priority 2)"
:Modify Privilege Enable (``mprven``): Enables/disables the modify privilege setting in debug mode.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0", "disable_mprv", "MPRV in ``mstatus`` is ignored in Debug Mode."
       "1", "enable_mprv", "MPRV in ``mstatus`` takes effect in Debug Mode."
:Non-Maskable Interrupt Pending (``nmip``): When set, there is a Non-Maskable-Interrupt (NMI) pending for the hart.

:Step (``step``): When set and not in Debug Mode, the hart will only execute a single instruction and then enter Debug Mode. If the instruction does not complete due to an exception, the hart will immediately enter Debug Mode before executing the trap handler, with appropriate exception registers set. The debugger must not change the value of this bit while the hart is running.

:Privilege level (``prv``): Contains the privilege level the hart was operating in when Debug Mode was entered. A debugger can change this value to change the hart’s privilege level when exiting Debug Mode.

    .. csv-table:: The following table shows the bitfield encoding
       :widths: auto
       :align: left
       :header: "Value", "Name", "Description"

       "0b00", "User", ""
       "0b01", "Supervisor", ""
       "0b11", "Machine", ""

Debug PC (``dpc``)
~~~~~~~~~~~~~~~~~~

:Address Offset: 0x7B1
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Upon entry to debug mode, ``dpc`` is updated with the virtual address of the next instruction to be executed.

    When resuming, the hart’s PC is updated to the virtual address stored in ``dpc``. A debugger may write ``dpc`` to change where the hart resumes.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``dpc``", "", "RW", "0b0"

:``dpc``: The ``dpc`` behavior is described in more detail in the table below.

    .. csv-table::
      :header: "Cause", "Virtual Address in DPC"

      "``ebreak``", "Address of the ``ebreak`` instruction."
      "single step", "Address of the instruction that would be executed next if no debugging was going on. Ie. pc + 4 for 32-bit instructions that don’t change program flow, the destination PC on taken jumps/branches, etc."
      "trigger module", "If ``timing`` is 0, the address of the instruction which caused the trigger to fire. If ``timing`` is 1, the address of the next instruction to be executed at the time that debug mode was entered."
      "halt request", "Address of the next instruction to be executed at the time that debug mode was entered."


Debug Scratch Register (``dscratch[2]``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0x7B2 [+ i*0x1]
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Optional scratch register. A debugger must not write to this register unless ``hartinfo`` explicitly mentions it.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``dscratch``", "", "RW", "0b0"


``ftran``
~~~~~~~~~

:Address Offset: 0x800
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Floating Point Custom CSR

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:7]", "``reserved_0``", "Reserved", "RO", "0b0"
   "[6:0]", "``ftran``", "", "RW", "0b0"

:``ftran``: Floating Point Custom CSR


M-mode Cycle counter (``mcycle``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB00
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Counts the number of clock cycles executed by the processor core on which the hart is running.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"

:Count (``count``): Counts the number of clock cycles executed by the processor core.


Machine Instruction Retired counter (``minstret``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB02
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Counts the number of instructions the hart has retired.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"

:Count (``count``): Counts the number of instructions the hart has retired.


L1 Inst Cache Miss (``ml1_icache_miss``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB03
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


L1 Data Cache Miss (``ml1_dcache_miss``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB04
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


ITLB Miss (``mitlb_miss``)
~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB05
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


DTLB Miss (``mdtlb_miss``)
~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB06
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Loads (``mload``)
~~~~~~~~~~~~~~~~~

:Address Offset: 0xB07
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Stores (``mstore``)
~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB08
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Taken Exceptions (``mexception``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB09
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Exception Return (``mexception_ret``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB0A
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Software Change of PC (``mbranch_jump``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB0B
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Procedure Call (``mcall``)
~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB0C
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Procedure Return (``mret``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB0D
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Branch mis-predicted (``mmis_predict``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB0E
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Scoreboard Full (``msb_full``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB0F
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Instruction Fetch Queue Empty (``mif_empty``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB10
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Upper 32-bits of M-mode Cycle counter (``mcycleh``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB80
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Counts the number of clock cycles executed by the processor core on which the hart is running.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"

:Count (``count``): Counts the number of clock cycles executed by the processor core.


Upper 32-bits of Machine Instruction Retired counter (``minstreth``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB82
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Counts the number of instructions the hart has retired.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"

:Count (``count``): Counts the number of instructions the hart has retired.


Upper 32-bits of Machine Hardware Performance Monitoring Counter (``mhpmcounterh[6]``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xB83 [+ i*0x1]
:Width (bits): 32
:Access Type: RW
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RW", "0b0"


Cycle counter (``cycle``)
~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC00
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Cycle counter for RDCYCLE instruction.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Timer (``time``)
~~~~~~~~~~~~~~~~

:Address Offset: 0xC01
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Timer for RDTIME instruction.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Instruction Retired counter (``instret``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC02
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Instructions-retired counter for RDINSTRET instruction

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


L1 Inst Cache Miss (``l1_icache_miss``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC03
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


L1 Data Cache Miss (``l1_dcache_miss``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC04
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


ITLB Miss (``itlb_miss``)
~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC05
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


DTLB Miss (``dtlb_miss``)
~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC06
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Loads (``load``)
~~~~~~~~~~~~~~~~

:Address Offset: 0xC07
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Stores (``store``)
~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC08
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Taken Exceptions (``exception``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC09
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Exception Return (``exception_ret``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC0A
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Software Change of PC (``branch_jump``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC0B
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Procedure Call (``call``)
~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC0C
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Procedure Return (``ret``)
~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC0D
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Branch mis-predicted (``mis_predict``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC0E
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Scoreboard Full (``sb_full``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC0F
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Instruction Fetch Queue Empty (``if_empty``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC10
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Hardware performance event counter.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Upper 32-bits of Cycle counter (``cycleh``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC80
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Cycle counter for RDCYCLE instruction.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Upper 32-bit of Timer (``timeh``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC81
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Timer for RDTIME instruction.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Upper 32-bits of Instruction Retired counter (``instreth``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xC82
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Instructions-retired counter for RDINSTRET instruction

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``count``", "Count", "RO", "0b0"


Machine Vendor ID (``mvendorid``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xF11
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: This register provides the JEDEC manufacturer ID of the provider of the core.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:7]", "``bank``", "Bank", "RO", "0b0"
   "[6:0]", "``offset``", "Offset", "RO", "0b0"

:Bank (``bank``): Contain encoding for number of one-byte continuation codes discarding the parity bit.

:Offset (``offset``): Contain encoding for the final byte discarding the parity bit.


Machine Architecture ID (``marchid``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xF12
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000003
:Description: This register encodes the base microarchitecture of the hart.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``architecture_id``", "Architecture ID", "RO", "0b11"

:Architecture ID (``architecture_id``): Provide Encoding the base microarchitecture of the hart.


Machine Implementation ID (``mimpid``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xF13
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: Provides a unique encoding of the version of the processor implementation.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``implementation``", "Implementation", "RO", "0b0"

:Implementation (``implementation``): Provides unique encoding of the version of the processor implementation.


Machine Hardware Thread ID (``mhartid``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Address Offset: 0xF14
:Width (bits): 32
:Access Type: RO
:Reset Value: 0x00000000
:Description: This register contains the integer ID of the hardware thread running the code.

.. csv-table::
   :widths: auto
   :align: left
   :header: "Bits", "Name", "Display Name", "Access Type", "Reset"

   "[31:0]", "``hart_id``", "Hart ID", "RO", "0b0"

:Hart ID (``hart_id``): Contains the integer ID of the hardware thread running the code.

