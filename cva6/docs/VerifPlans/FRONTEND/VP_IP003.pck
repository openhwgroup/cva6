(VPC generation stage
p0
ccopy_reg
_reconstructor
p1
(cvp_pack
Ip
p2
c__builtin__
object
p3
Ntp4
Rp5
(dp6
Vprop_count
p7
I10
sVname
p8
g0
sVprop_list
p9
(dp10
sVip_num
p11
I3
sVwid_order
p12
I3
sVrfu_dict
p13
(dp14
sVrfu_list
p15
(lp16
(V001_BTB
p17
g1
(cvp_pack
Prop
p18
g3
Ntp19
Rp20
(dp21
Vitem_count
p22
I6
sg8
g17
sVtag
p23
VVP_IP003_P001
p24
sVitem_list
p25
(dp26
sg12
I1
sg15
(lp27
(V000
p28
g1
(cvp_pack
Item
p29
g3
Ntp30
Rp31
(dp32
g8
V000
p33
sg23
VVP_IP003_P001_I000
p34
sVdescription
p35
VIf instruction is a JALR and BTB (Branch Target Buffer) returns a valid address, next PC is predicted by BTB. Else JALR is not considered as a control flow instruction, which will generate a mispredict.
p36
sVpurpose
p37
VFRONTEND sub-system/functionality/PC generation stage/Branch Predict
p38
sVverif_goals
p39
VExecute a JALR instruction with a valid address in BTB which is not a misprediction. Check that instruction queue is not flushed.
p40
sVcoverage_loc
p41
V
p42
sVpfc
p43
I4
sVtest_type
p44
I0
sVcov_method
p45
I1
sVcores
p46
I16
sVcomments
p47
g42
sVstatus
p48
g42
sVsimu_target_list
p49
(lp50
sg15
(lp51
sVrfu_list_2
p52
(lp53
sg13
(dp54
Vlock_status
p55
I0
ssbtp56
a(V001
p57
g1
(g29
g3
Ntp58
Rp59
(dp60
g8
V001
p61
sg23
VVP_IP003_P001_I001
p62
sg35
VIf instruction is a JALR and BTB (Branch Target Buffer) returns a valid address, next PC is predicted by BTB. Else JALR is not considered as a control flow instruction, which will generate a mispredict.
p63
sg37
VFRONTEND sub-system/functionality/PC generation stage/Branch Predict
p64
sg39
VExecute a JALR instruction with a valid address in BTB which is a misprediction.
p65
sg41
g42
sg43
I3
sg44
I0
sg45
I1
sg46
I16
sg47
g42
sg48
g42
sg49
(lp66
sg15
(lp67
sg52
(lp68
sg13
(dp69
g55
I0
ssbtp70
a(V002
p71
g1
(g29
g3
Ntp72
Rp73
(dp74
g8
V002
p75
sg23
VVP_IP003_P001_I002
p76
sg35
VIf instruction is a JALR and BTB (Branch Target Buffer) returns a valid address, next PC is predicted by BTB.\u000a\u000aElse JALR is not considered as a control flow instruction, which will generate a mispredict.
p77
sg37
VFRONTEND sub-system/functionality/PC generation stage/Branch Predict
p78
sg39
VExecute test with JALR instructions. Functional cov: JALR is executed and BTB output is not valid.
p79
sg41
g42
sg43
I3
sg44
I0
sg45
I1
sg46
I8
sg47
g42
sg48
g42
sg49
(lp80
sg15
(lp81
sg52
(lp82
sg13
(dp83
g55
I0
ssbtp84
asVrfu_list_1
p85
(lp86
sg52
(lp87
sg13
(dp88
sbtp89
a(V002_BHT
p90
g1
(g18
g3
Ntp91
Rp92
(dp93
g22
I4
sg8
g90
sg23
VVP_IP003_P002
p94
sg25
(dp95
sg12
I2
sg15
(lp96
(V000
p97
g1
(g29
g3
Ntp98
Rp99
(dp100
g8
V000
p101
sg23
VVP_IP003_P002_I000
p102
sg35
VIf instruction is a branch and BTH (Branch History table) returns a valid address, next PC is predicted by BHT. Else branch is not considered as an control flow instruction, which will generate a mispredict when branch is taken.
p103
sg37
VFRONTEND sub-system/functionality/PC generation stage/Branch Predict
p104
sg39
VExecute a BRANCH instruction with a valid address in BHT which is not a misprediction. Check that instruction queue is not flushed.
p105
sg41
g42
sg43
I4
sg44
I0
sg45
I1
sg46
I16
sg47
g42
sg48
g42
sg49
(lp106
sg15
(lp107
sg52
(lp108
sg13
(dp109
Vlock_status
p110
I0
ssbtp111
a(V001
p112
g1
(g29
g3
Ntp113
Rp114
(dp115
g8
V001
p116
sg23
VVP_IP003_P002_I001
p117
sg35
VIf instruction is a branch and BTH (Branch History table) returns a valid address, next PC is predicted by BHT. Else branch is not considered as an control flow instruction, which will generate a mispredict when branch is taken.
p118
sg37
VFRONTEND sub-system/functionality/PC generation stage/Branch Predict
p119
sg39
VExecute a BRANCH instruction with a valid address in BHT which is a misprediction.
p120
sg41
g42
sg43
I3
sg44
I0
sg45
I1
sg46
I16
sg47
g42
sg48
g42
sg49
(lp121
sg15
(lp122
sg52
(lp123
sg13
(dp124
Vlock_status
p125
I0
ssbtp126
a(V002
p127
g1
(g29
g3
Ntp128
Rp129
(dp130
g8
V002
p131
sg23
VVP_IP003_P002_I002
p132
sg35
VIf instruction is a branch and BTH (Branch History table) returns a valid address, next PC is predicted by BHT. Else branch is not considered as an control flow instruction, which will generate a mispredict when branch is taken.
p133
sg37
VFRONTEND sub-system/functionality/PC generation stage/Branch Predict
p134
sg39
VExecute test with BRANCH instructions. Functional cov: a BRANCH is executed, BTB output is not valid and the branch is taken.
p135
sg41
g42
sg43
I3
sg44
I0
sg45
I1
sg46
I8
sg47
g42
sg48
g42
sg49
(lp136
sg15
(lp137
sg52
(lp138
sg13
(dp139
g125
I0
ssbtp140
asg85
(lp141
sg52
(lp142
sg13
(dp143
sbtp144
a(V003_RAS
p145
g1
(g18
g3
Ntp146
Rp147
(dp148
g22
I4
sg8
g145
sg23
VVP_IP003_P003
p149
sg25
(dp150
sg12
I3
sg15
(lp151
(V000
p152
g1
(g29
g3
Ntp153
Rp154
(dp155
g8
V000
p156
sg23
VVP_IP003_P003_I000
p157
sg35
VIf instruction is a RET and RAS (Return Address Stack) returns a valid address and RET has already been consummed by instruction queue. Else RET is considered as a control flow instruction but next PC is not predicted. A mispredict wil be generated.
p158
sg37
VFRONTEND sub-system/functionality/PC generation stage/Branch Predict
p159
sg39
VExecute a RET instruction with a valid address in RAS. Check that instruction queue is not flushed.
p160
sg41
g42
sg43
I3
sg44
I0
sg45
I1
sg46
I16
sg47
g42
sg48
g42
sg49
(lp161
sg15
(lp162
sg52
(lp163
sg13
(dp164
g125
I0
ssbtp165
a(V001
p166
g1
(g29
g3
Ntp167
Rp168
(dp169
g8
V001
p170
sg23
VVP_IP003_P003_I001
p171
sg35
VIf instruction is a RET and RAS (Return Address Stack) returns a valid address and RET has already been consummed by instruction queue. Else RET is considered as a control flow instruction but next PC is not predicted. A mispredict wil be generated.
p172
sg37
VFRONTEND sub-system/functionality/PC generation stage/Branch Predict
p173
sg39
VExecute a RET instruction with a valid address in RAS which is a misprediction.
p174
sg41
g42
sg43
I3
sg44
I0
sg45
I1
sg46
I16
sg47
g42
sg48
g42
sg49
(lp175
sg15
(lp176
sg52
(lp177
sg13
(dp178
g125
I0
ssbtp179
a(V002
p180
g1
(g29
g3
Ntp181
Rp182
(dp183
g8
V002
p184
sg23
VVP_IP003_P003_I002
p185
sg35
VIf instruction is a RET and RAS (Return Address Stack) returns a valid address and RET has already been consummed by instruction queue. Else RET is considered as a control flow instruction but next PC is not predicted. A mispredict wil be generated.
p186
sg37
VFRONTEND sub-system/functionality/PC generation stage/Branch Predict
p187
sg39
VExecute test with RET instructions. Functional cov: RET is executed and RAS output is not valid.
p188
sg41
g42
sg43
I3
sg44
I0
sg45
I1
sg46
I8
sg47
g42
sg48
g42
sg49
(lp189
sg15
(lp190
sg52
(lp191
sg13
(dp192
g125
I0
ssbtp193
asg85
(lp194
sg52
(lp195
sg13
(dp196
sbtp197
a(V004_Return from environment call
p198
g1
(g18
g3
Ntp199
Rp200
(dp201
g22
I2
sg8
g198
sg23
VVP_IP003_P004
p202
sg25
(dp203
sg12
I4
sg15
(lp204
(V000
p205
g1
(g29
g3
Ntp206
Rp207
(dp208
g8
V000
p209
sg23
VVP_IP003_P004_I000
p210
sg35
VWhen CSR asks a return from an environment call, the PC is assigned to the successive PC to the one stored in the CSR [m-s]epc register.
p211
sg37
VFRONTEND sub-system/functionality/PC generation stage/Return from env call
p212
sg39
VSet two different addresses for mepc and sepc in CSR registers. Use a arc_test returning from machine env call. Check by assertion that when machine return occurs the mepc address is fetched. Functional cov: execute a machine return.
p213
sg41
g42
sg43
I4
sg44
I0
sg45
I1
sg46
I8
sg47
g42
sg48
g42
sg49
(lp214
sg15
(lp215
sg52
(lp216
sg13
(dp217
g125
I0
ssbtp218
a(V001
p219
g1
(g29
g3
Ntp220
Rp221
(dp222
g8
V001
p223
sg23
VVP_IP003_P004_I001
p224
sg35
VWhen CSR asks a return from an environment call, the PC is assigned to the successive PC to the one stored in the CSR [m-s]epc register.
p225
sg37
VFRONTEND sub-system/functionality/PC generation stage/Return from env call
p226
sg39
VSet two different addresses for mepc and sepc in CSR registers. Use a returning from supervisor env call. Check by assertion that when supervisor return occurs the sepc address is fetched. Functional cov: execute a supervisor return.
p227
sg41
g42
sg43
I4
sg44
I0
sg45
I1
sg46
I16
sg47
g42
sg48
g42
sg49
(lp228
sg15
(lp229
sg52
(lp230
sg13
(dp231
g125
I0
ssbtp232
asg85
(lp233
sg52
(lp234
sg13
(dp235
sbtp236
a(V005_Exception/Interrupt
p237
g1
(g18
g3
Ntp238
Rp239
(dp240
g22
I2
sg8
g237
sg23
VVP_IP003_P005
p241
sg25
(dp242
sg12
I5
sg15
(lp243
(V000
p244
g1
(g29
g3
Ntp245
Rp246
(dp247
g8
V000
p248
sg23
VVP_IP003_P005_I000
p249
sg35
VIf an exception (or interrupt, which is in the context of RISC-V systems quite similar) is triggered by the COMMIT, the next PC Gen is assigned to the CSR trap vector base address. The trap vector base address can be different depending on whether the exception traps to S-Mode or M-Mode (user mode exceptions are currently not supported)
p250
sg37
VFRONTEND sub-system/functionality/PC generation stage/Exception
p251
sg39
VSet two different addresses for machine and supervisor handlers in CSR registers. Use a test which executes in machine mode and generates a machine exception by UVM. Check by assertion that when machine exception occurs the machine address is fetched. Functional cov: exception occurs in machine mode.
p252
sg41
g42
sg43
I4
sg44
I0
sg45
I1
sg46
I8
sg47
g42
sg48
g42
sg49
(lp253
sg15
(lp254
sg52
(lp255
sg13
(dp256
g125
I0
ssbtp257
a(V001
p258
g1
(g29
g3
Ntp259
Rp260
(dp261
g8
V001
p262
sg23
VVP_IP003_P005_I001
p263
sg35
VIf an exception (or interrupt, which is in the context of RISC-V systems quite similar) is triggered by the COMMIT, the next PC Gen is assigned to the CSR trap vector base address. The trap vector base address can be different depending on whether the exception traps to S-Mode or M-Mode (user mode exceptions are currently not supported)
p264
sg37
VFRONTEND sub-system/functionality/PC generation stage/Exception
p265
sg39
VSet two different addresses for machine and supervisor handlers in CSR registers. Use a test which executes in supervisor mode and generates a supervisor exception by UVM. Check by assertion that when supervisor exception occurs the supervisor address is fetched. functional cov: exception occurs in supervisor mode.
p266
sg41
g42
sg43
I3
sg44
I0
sg45
I1
sg46
I16
sg47
g42
sg48
g42
sg49
(lp267
sg15
(lp268
sg52
(lp269
sg13
(dp270
g125
I0
ssbtp271
asg85
(lp272
sg52
(lp273
sg13
(dp274
sbtp275
a(V006_Pipeline flush
p276
g1
(g18
g3
Ntp277
Rp278
(dp279
g22
I2
sg8
g276
sg23
VVP_IP003_P006
p280
sg25
(dp281
sg12
I6
sg15
(lp282
(V000
p283
g1
(g29
g3
Ntp284
Rp285
(dp286
g8
V000
p287
sg23
VVP_IP003_P006_I000
p288
sg35
VFRONTEND starts fetching from the next instruction again in order to take the up-dated information into account
p289
sg37
VFRONTEND sub-system/functionality/PC generation stage/Pipeline flush
p290
sg39
V[no need to verify this point]
p291
sg41
g42
sg43
I-1
sg44
I-1
sg45
I-1
sg46
I8
sg47
g42
sg48
g42
sg49
(lp292
sg15
(lp293
sg52
(lp294
sg13
(dp295
g125
I0
ssbtp296
asg85
(lp297
sg52
(lp298
sg13
(dp299
sbtp300
a(V007_Debug
p301
g1
(g18
g3
Ntp302
Rp303
(dp304
g22
I1
sg8
g301
sg23
VVP_IP003_P007
p305
sg25
(dp306
sg12
I7
sg15
(lp307
(V000
p308
g1
(g29
g3
Ntp309
Rp310
(dp311
g8
V000
p312
sg23
VVP_IP003_P007_I000
p313
sg35
VThe debug jump is requested by CSR. The address to be jumped into is HW coded.
p314
sg37
VFRONTEND sub-system/functionality/PC generation stage/Debug
p315
sg39
VUVM generates a debug request to jump into debug handler. Check by assertion that the HW coded debug address is fetched. Functional cov: debug mode occurs
p316
sg41
g42
sg43
I4
sg44
I0
sg45
I1
sg46
I32
sg47
g42
sg48
g42
sg49
(lp317
sg15
(lp318
sg52
(lp319
sg13
(dp320
g125
I0
ssbtp321
asg85
(lp322
sg52
(lp323
sg13
(dp324
sbtp325
a(V008_Address mapping change
p326
g1
(g18
g3
Ntp327
Rp328
(dp329
g22
I1
sg8
g326
sg23
VVP_IP003_P008
p330
sg25
(dp331
sg12
I8
sg15
(lp332
(V000
p333
g1
(g29
g3
Ntp334
Rp335
(dp336
g8
V000
p337
sg23
VVP_IP003_P008_I000
p338
sg35
VAll program counters are logical addressed. If the logical to physical mapping changes a fence.vm instruction should used to flush the pipeline and TLBs
p339
sg37
VFRONTEND sub-system/functionality/PC generation stage
p340
sg39
VExecute a address mapping change, then execute a fence.vm instruction, and continue the execution.
p341
sg41
g42
sg43
I-1
sg44
I-1
sg45
I-1
sg46
I16
sg47
g42
sg48
g42
sg49
(lp342
sg15
(lp343
sg52
(lp344
sg13
(dp345
g125
I0
ssbtp346
asg85
(lp347
sg52
(lp348
sg13
(dp349
sbtp350
a(V009_Pc gen priority
p351
g1
(g18
g3
Ntp352
Rp353
(dp354
g22
I3
sg8
g351
sg23
VVP_IP003_P009
p355
sg25
(dp356
sg12
I9
sg15
(lp357
(V000
p358
g1
(g29
g3
Ntp359
Rp360
(dp361
g8
V000
p362
sg23
VVP_IP003_P009_I000
p363
sg35
VThe next PC can originate from the following sources (listed in order of precedence)
p364
sg37
VFRONTEND sub-system/functionality/PC generation stage
p365
sg39
VUse arc_test executing return from env call and generate Exceptions by UVM during reset, Branch predict, default, mispredict, replay and return from env call. Functional cov: monitor the 6 events
p366
sg41
g42
sg43
I3
sg44
I0
sg45
I1
sg46
I8
sg47
g42
sg48
g42
sg49
(lp367
sg15
(lp368
sg52
(lp369
sg13
(dp370
g125
I0
ssbtp371
a(V002
p372
g1
(g29
g3
Ntp373
Rp374
(dp375
g8
V002
p376
sg23
VVP_IP003_P009_I002
p377
sg35
VThe next PC can originate from the following sources (listed in order of precedence)
p378
sg37
VFRONTEND sub-system/functionality/PC generation stage
p379
sg39
V[other cases to be elaborated]
p380
sg41
g42
sg43
I-1
sg44
I-1
sg45
I-1
sg46
I8
sg47
g42
sg48
g42
sg49
(lp381
sg15
(lp382
sg52
(lp383
sg13
(dp384
g125
I0
ssbtp385
asg85
(lp386
sg52
(lp387
sg13
(dp388
sbtp389
asVrfu_list_0
p390
(lp391
sg85
(lp392
sVvptool_gitrev
p393
V$Id$
p394
sbtp395
.